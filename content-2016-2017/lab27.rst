Автоматы
########

:date: 2017-04-25
:lecture_link: https://youtu.be/U6Cu9o1X1N4
:lecture_pdf: true

.. default-role:: code
.. contents:: Содержание


Машина Алана Тьюринга
=====================

`Машина Тьюринга`__ — абстрактный исполнитель, состоящий из бесконечной ленты, разделённой на ячейки, и управляющего
устройства. На ленте записаны символы входной последовательности из заранее оговорённого алфавита; также выделяется
специальный пустой символ, которым заполнены все «клетки» ленты, кроме тех, в которых заданы входные данные. Управляющее
устройство реализует непосредственно логику работы самой машины, т.е. в нём задан определённый набор правил следующего
вида: «Если машина находится в состоянии A и в текущей позиции на ленте находится символ X, то ⑴ нужно записать в текущую
позицию символ Y, ⑵ перейти в состояние B, ⑶ выбрать новое текущее положение на ленте из трёх вариантов: та же самая
ячейка, ячейка слева или ячейка справа».

.. __:	https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%B0_%D0%A2%D1%8C%D1%8E%D1%80%D0%B8%D0%BD%D0%B3%D0%B0

Пример машины Тьюринга, реализующей прибавление единицы к двоичному числу, можно посмотреть `здесь`__.

.. __: http://matinf.igpu.ru/simulator/tm.html

Несмотря на то, что классический вариант машины Тьюринга предполагает наличие бесконечной ленты (в обе стороны),
достаточно просто показать, что машина Тьюринга с полубесконечной лентой эквивалентна классической машине.

Упражнение №1
-------------

Реализуйте эмулятор машины Тьюринга. Программа должна считывать входные данные из двух файлов: из одного список правил
для смены состояний, из другого — начальные данные.

Указание: Если использовать такой же формат задания правил машины Тьюринга как по ссылке выше, его можно распознать регулярным выражением `^(.)q(\d+)->(.)(q(\d+)(.)|STOP)$`.

Упражнение №2
-------------

Для реализованного эмулятора машины Тьюринга напишите следующие алгоритмы:

#. Умножение двоичного числа на 2.
#. Перенести первый символ слова в конец (слово состоит из символов a,b,c,d).
#. Стереть непустое слово, если его первый и последний символ одинаковы. В противном случае оставить слово без изменений.
#. Удалить из слова второй символ, если такой есть (слово состоит из символов a,b).
#. Удалить из слова первое вхождение символа a, если такое имеется (слово состоит из символов a,b,c).

Клеточный автомат
=================

`Клеточный автомат`__ — это математическая модель, описывающая эволюционирующую во времени систему, состояние которой в
каждый момент времени определяется её состоянием в предыдущий момент. Клеточный автомат состоит из набора клеток, для
каждой из которых задана окрестность, т.е. набор соседних клеток. Для всего автомата в целом задаются правила изменения
состояния клетки в зависимости от состояния клеток, находящихся в её окрестности.

.. __: https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82

Одномерный клеточный автомат
----------------------------

Рассмотрим простейший пример одномерного клеточного автомата. Под одномерным клеточным автоматом в данном случае
понимается автомат, состоящий из клеток, выстроенных в линию. Т.е. в данном случае у каждой клетки есть ровно два соседа:
один слева и один справа.

Пусть поведение клеточного автомата подчиняется следующим правилам:

#. Клетка находится в одном из двух состояний: 1 или 0.
#. Состояние в следующий момент времени вычисляется следующим образом: `_A[i] = (A[i-1] + A[i+1]) % 2`. Т.е. клетка
   находится в состоянии 1, если в предыдущий момент в этом состянии находилась ровно одна соседняя клетка.

Пример программы, реализующей описанный выше клеточный автомат:

.. code-block:: python

   N = 35

   def cell_calculate(left, current, right):
       return left^right

   def calculate_field(field):
       """field -- список из N ноликов или единичек"""
       new_field = [0]*N
       for i in range(1, N-1):
           new_field[i] = cell_calculate(field[i-1], field[i], field[i+1])
       field[:] = new_field

   def generate_field():
       field = [0]*N
       x = N//2
       field[x] = 1
       return field

   def print_field(field):
       for cell in field:
           print('★' if cell else ' ' , end = '')
       print()

   def modelling():
       """ цикл моделирования клеточного автомата """
       field = generate_field()
       print_field(field)
       for t in range(15):
           calculate_field(field)
           print_field(field)

   if __name__ == '__main__':
       modelling()

Вывод программы:

.. code-block:: text

                 ★                 
                ★ ★                
               ★   ★               
              ★ ★ ★ ★              
             ★       ★             
            ★ ★     ★ ★            
           ★   ★   ★   ★           
          ★ ★ ★ ★ ★ ★ ★ ★          
         ★               ★         
        ★ ★             ★ ★        
       ★   ★           ★   ★       
      ★ ★ ★ ★         ★ ★ ★ ★      
     ★       ★       ★       ★     
    ★ ★     ★ ★     ★ ★     ★ ★    
   ★   ★   ★   ★   ★   ★   ★   ★   
  ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ 


Нетрудно заметить, что результат работы такого клеточного автомата внешне выглядит как дискретный аналог
`треугольника Серпинского`__.

.. __: https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B5%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA_%D0%A1%D0%B5%D1%80%D0%BF%D0%B8%D0%BD%D1%81%D0%BA%D0%BE%D0%B3%D0%BE

Код Вольфрама
----------------------------

Если клетка автомата может находится только в двух состояниях, такой автомат называется бинарным. Одномерный бинарный клеточный автомат принято называть простейшим(элементарным), если состояние клетки в любой момент времени зависит только от её собственного состояния и состояния смежных клеток в предыдущий момент времени(окрестности радиуса 1).

Элементарных клеточных автоматов существует всего 256, так как состояний для трёх соседних клеток может быть 2**3, и для каждого состояния может быть два варианта задать новое значение центральной клетки.
Стивен Вольфрам предложил нумеровать эти автоматы числами от 0 до 255, это именование и называется `Код Вольфрама`__.

.. __: https://en.wikipedia.org/wiki/Wolfram_code

Способ нумерования: запишем конфигурации окрестности в виде двоичного числа и отсортируем конфигурации по убыванию. Тогда сам клеточный автомат можо представить как упорядоченный набор результирующих значений для каждой конфигурации, то есть тоже число в двоичной системе счисления, это и будет номер этого клеточного автомата. (Автомат из примера будет это номер 18)

Например для номера 110, в зависимости от состояний соседа слева, самой клетки и соседа справа (первая строка таблицы) на следующем шаге клетка примет одно из состояний, указанных во второй строке.

+-----+-----+-----+-----+-----+-----+-----+-----+
| 111 | 110 | 101 | 100 | 011 | 010 | 001 | 000 |
+=====+=====+=====+=====+=====+=====+=====+=====+
|  0  |  1  |  1  |  0  |  1  |  1  |  1  |  0  |
+-----+-----+-----+-----+-----+-----+-----+-----+

Упражнение №3
+++++++++++++

Напишите программу, реализующую элементарный коннечный автомат по его коду Вольфрама переданному на ввод. Программа должна считывать начальное состояние клеточной ленты из файла.

Указание: Чтобы вычислять значения клеток на концах нужно замкнуть автомат в кольцо - сделать крайнюю левую клетку правым соседом крайней правой и наоборот.

Игра «Жизнь» Джона Конвея
-------------------------

`Игра «Жизнь»`__ — это двумерный клеточный автомат, предложенный математиком Джоном Конвеем. Поведение этого клеточного
автомата подчиняется следующим правилам:

#. Автомат работает на плоскости, разделённой на одинаковые квадратные клетки.
#. Каждая клетка может находиться в двух состояниях: живая или мёртвая.
#. В начальный момент времени задано первое поколение — расположение живых клеток на плоскости.
#. Каждое следующее поколение рассчитывается исходя из состояния прошлого поколения по следующим правилам:

   * в мёртвой клетке зарождается жизнь, если у этой клетки ровно три живых соседних клетки;
   * если у живой клетки есть две или три живых соседних клетки, то клетка продолжает жить, в противном случае клетка
     погибает.

#. Игра завершается в трёх случаях:

   * все клетки погибли;
   * клетки сформировали устойчивую конфигурацию (т.е. на новом шаге не родилось и не погибло ни одной клетки);
   * клетки сформировали периодическую конфигурацию (т.е. клетки в точности повторили свою конфигурацию в один из
     предыдущих моментов).

.. __: https://ru.wikipedia.org/wiki/%D0%96%D0%B8%D0%B7%D0%BD%D1%8C_(%D0%B8%D0%B3%D1%80%D0%B0)

Упражнение №4
+++++++++++++

Напишите программу, реализующую игру «Жизнь». Программа должна считывать начальное состояние поля из текстового файла.

Упражнение №5
+++++++++++++

Проверьте свою программу при помощи известных конфигураций клеток:

* `осцилляторы`__;
* `космические корабли`__;
* `натюрморты`__;
* `планерное ружьё Госпера`__.

.. __: https://ru.wikipedia.org/wiki/%D0%9E%D1%81%D1%86%D0%B8%D0%BB%D0%BB%D1%8F%D1%82%D0%BE%D1%80_(%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B0)
.. __: https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%81%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BA%D0%BE%D1%80%D0%B0%D0%B1%D0%BB%D1%8C_(%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B0)
.. __: https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D1%82%D1%8E%D1%80%D0%BC%D0%BE%D1%80%D1%82_(%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B0)#.D0.9F.D1.80.D0.BE.D1.81.D1.82.D1.8B.D0.B5_.D0.BF.D1.80.D0.B8.D0.BC.D0.B5.D1.80.D1.8B
.. __: http://www.conwaylife.com/w/index.php?title=Gosper_glider_gun
