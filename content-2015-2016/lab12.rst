Наследование и диаграммы классов UML
####################################

:date: 2015-11-13 17:00
:lecture_link: https://youtu.be/BmKd1aqrnRg
:lecture_pdf: true
:status: draft

.. default-role:: code
.. contents:: Содержание

Постановка проблемы
===================

Классы создаются для объединения кода и функций, его обрабатывающих. Однако, несколько классов часто оказываются настолько похожими, что код приходится дублировать.

.. code-block:: python

	class Student(UniversityMember):
	    group = None
	    passToUniversity = ''
	    status = True

	    def checkStatus(self):
	        return self.status

	    def dismiss(self):
	        self.status = False
	        self.pass_to_university = None

	class Teacher(UniversityMember):
	    cathedral = None
	    passToUniversity = ''
	    status = True

	    def checkStatus(self):
	        return self.status

	    def dismiss(self):
	        self.status = False
	        self.pass_to_university = None

	class Administrator(UniversityMember):
	    passToUniversity = ''
	    status = True

	    def checkStatus(self):
	        return self.status

	    def dismiss(self):
	        self.status = False
	        self.pass_to_university = None

В данном случае и у студента, и у преподавателя и у администратора должны быть свойства `status` и `pass_to_university`, возможность проверки статуса и возможность увольнения.

При этом объём продублированного кода столь значителен, что "рябит в глазах" и трудно заметить различие классов.

Наследование классов
====================

Заменим дублирование кода явным **наследованием** от абстактного класса `UniversityMember`:

.. image:: {filename}/images/lab12/example.png

.. code-block:: python

	class UniversityMember:
	    passToUniversity = ''
	    status = True

	    def checkStatus(self):
	        return self.status

	    def dismiss(self):
	        self.status = False
	        self.pass_to_university = None

	class Student(UniversityMember):
	    group = None

	class Teacher(UniversityMember):
	    cathedral = None

	class Administrator(UniversityMember):
		pass

Диаграмма, которая отображает наследование называется **диаграммой классов**, и на ней могут быть изображены также методы и атрибуты классов:

.. image:: {filename}/images/lab12/example_uml.png

Язык объектно-ориентированного моделирования UML_ включает в себя не только диаграммы классов, но и множество других диаграмм, позволяющих лучше представить будущую программу.

.. _UML: https://ru.wikipedia.org/wiki/UML

Определения
-----------

Рассмотрим простое наследование:

.. image:: {filename}/images/lab12/definitions.png

.. code-block:: python

	class Base:
	    pass

	class Derived(Base):
	    pass

Класс `Base` в данном случае является **базовым классом**, **родительским классом**, **надклассом**, **суперклассом**, **предком**.

Класс `Derived` по отношению к нему является **производным классом**, **дочерним классом**, **подклассом**, **потомком**.

Говорят, что `Derived` **наследует**, **расширяет** или **специализирует** `Base`.

В языке Python 3 существует единый базовый класс object, который неявно является предком всех объектов вообще.

Перегрузка методов
------------------

Любой метод можно **переопределить**, то есть повторно реализовать в подклассе. В этом случае для экземпляров базового класса будет вызываться базовый метод, а для экземпляров производного -- перегруженный.

.. code-block:: python

	class Base:
	    def hello():
	        print("Hello! I'm base class!")

	class Derived(Base):
	    def hello():
	        print("Hello! I'm derived class!")

	b = Base()
	d = Derived()
	b.hello()	# Hello! I'm base class!
	d.hello()	# Hello! I'm derived class!

Этот механизм называется **динамическим связыванием методов** или **полиморфизмом**.

В языке Python используется механизм грубого определения типа (утиная типизация):

	When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.

Это значит, что если нам нужно вызвать некий метод объекта, то не важно, к какому классу относится этот объект, главное, чтобы он имел метод, который предполагается вызвать.

Множественное наследование
--------------------------

При множественном наследовании у класса может быть более одного предка. В этом случае класс-потомок наследует методы всех предков.

.. code-block:: python

	class SuperBase: # Предок предка
		def do(self):
	        print('Метод суперпредка!')
	class Base1(SuperBase):   # Предок 1
	    def do_it(self):
	        print('Метод предка 1')
	class Base2:   # Предок 2
	    def do_it(self):
	        print('Метод предка 2')
	class Derived(Base1, Base2):   # Наследник
	    def do_it_by_myself(self):
	        print('Метод наследника')

	d = Derived()   # инстанциация

	d.do_it_by_myself()  # Если в классе-потомке есть перегруженный метод с искомым названием
	                     # то он будет вызван независимо от наличия таких же методов у предков.

	d.do_it() # Если такого метода нет, то он ищется в порядке "лествичного права":
			  # в первую очередь у ближайших предков -- слева-направо,
			  # затем у их предков в том же порядке слева-направо, пока не будет найден.
			  # В данном случае будет вызван метод предка 1.

	d.do()	# Метод суперпредка вызывается, только если такого нет
	        # ни у класса, ни у его ближайших предков


Подстановочный критерий Барбары Лисков
--------------------------------------

Правильно используйте наследование!

Механизм наследования используется для моделирования отношений типа "является".

.. image:: {filename}/images/lab12/liskov.jpg

В случае с классами `Student`, `Teacher` и `Administrator` мы могли бы ошибочно могли бы сделать `Administrator` предком `Student` и `Teacher`, поскольку это позволяет сэкономить код, да и вроде бы они только расширяют его функциональность...

.. code-block:: python

	class Administrator:
	    passToUniversity = ''
	    status = True

	    def checkStatus(self):
	        return self.status

	    def dismiss(self):
	        self.status = False
	        self.pass_to_university = None

	class Student(Administrator):
	    group = None

	class Teacher(Administrator):
	    cathedral = None

Однако нарушена логика: ни студент не является админстратором, ни преподаватель. В незначительно отдалённом будущем при развитии проекта у администратора появится некоторые атрибуты или новая функциональность, которая попадёт в другие классы в следствие архитектурной ошибки. Например, всем администраторам выдаётся ключ от сейфа ректора...

Именно для того, чтобы избежать этой ошибочной логики мы применили абстрактное мышление и придумали класс `UniversityMember`.

Подстановочный критерий Барбары Лисков гласит также, что класс-потомок не только должен уметь делать всё то же, что и предок, но и не должен требовать для этого ничего лишнего.

Роберт С. Мартин определил этот принцип так:

    Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

Грубо говоря, если электрик чинил розетку за рубли, то его потомок должен, во-первых, уметь чинить розетку, во-вторых, уметь получить за это рубли (а не только доллары) и, в-третьих, не требовать для выполнения своей работы предварительных "танцев с бубном" (специфических предварительных инициализаций) или передачи дополнительных параметров в виде коробки конфет или бутылки водки.

Проект игры "Арифметические драконы"
====================================

Игра "Арифметические драконы" предназначена для обучения детей арифметике. На героя нападает дракон, который задаёт вопрос на сложение (если дракон зелёный), вычитание (красный) или умножение (чёрный).

1. Разбейтесь по командам по два программиста и сядьте за один компьютер.

2. Сделайте fork репозитория `arithmetic_dragons`_

.. _`arithmetic_dragons`: https://github.com/mipt-cs-on-python3/arithmetic_dragons

3. Реализуйте следующие классы:

.. image:: {filename}/images/lab12/dragons_uml.png

и добейтесь работоспособности игры.

4. Далее можете ввести новых атакующих юнитов:
	
	* тролля, который задаёт вопрос "Угадай число от 1 до 5"
	* тролля, который задаёт вопрос на простоту числа
	* тролля, который просит разложить число на множители и перечислить их через запятую

5. Сделайте графическую оболочку для данного проекта при помощи `tkinter.Canvas`.
