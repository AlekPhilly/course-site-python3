Практика: Динамическое программирование
#######################################

:date: 2017-11-10 12:10

.. default-role:: code

Описание
========

Динамическое программирование — решение сложной задачи разбиением её на более простые подзадачи, при этом каждая подзадача решается только один раз.

Динамическое программирование очень похоже на рекурсию, при этом:

- динамическое программирование сверху — это по сути рекурсия с кешированием;
- динамическое программирование снизу — это переформулирование  задачи в виде индуктивной последовательности подзадач, от крайнего случая к более сложным.

Одномерное динамическое программирование
========================================

Классическая задача — числа Фибоначчи
-------------------------------------

Последовательность Фибоначчи Fn задается формулами: F1 = 1, F2 = 1,
Fn = Fn – 1 + Fn – 2 при n > 1. Необходимо найти Fn по номеру n.

Один из способов решения, который может показаться логичным и эффективным, — решение с помощью рекурсии:

.. code-block:: python

	def fib(n):
		if n <= 1:
			return n
		else:
			return fib(n-1) + fib(n-2)

Используя такую функцию, мы будем решать задачу «с конца» — будем шаг за шагом уменьшать n, пока не дойдем до известных значений.

Но как можно заметить, такая, казалось бы, простая программа уже при n = 40 работает заметно долго. Это связано с тем, что одни и те же промежуточные данные вычисляются по несколько раз — число операций нарастает с той же скоростью, с какой растут числа Фибоначчи — экспоненциально.

Один из выходов из данной ситуации — сохранение уже найденных промежуточных результатов с целью их повторного использования (*кеширование*):

.. code-block:: python

	F = [-1]*MAX_POSSIBLE_N

	def fib(n):
		if n <= 1:
			return n
		if F[n] != -1:
			F[n] = fib(n-1) + fib(n-2)
		return F[n]

Приведенное решение корректно и эффективно. Но можно поступить ещё проще:

.. code-block:: python

	def fib(n):
		F = [-1]*(n+1)
		F[0] = 0
		F[1] = 1
		for i in range(2, n+1):
			F[i] = F[i - 1] + F[i - 2]
		return F[n]

Такое решение можно назвать решением «с начала» — мы первым делом заполняем известные значения, затем находим первое неизвестное значение, потом следующее и т.д., пока не дойдем до нужного.

Именно такое решение и является классическим для динамического программирования: мы сначала решили все подзадачи (нашли все ``F[i]`` для i < n), затем, зная решения подзадач, нашли ответ.

Задача о кузнечике — количество способов
----------------------------------------

Рассмотрим следующую задачу. На числовой прямой сидит кузнечик, который может прыгать вправо на одну или на две единицы. Первоначально кузнечик находится в точке с координатой 1. Определите количество различных маршрутов кузнечика, приводящих его в точку с координатой n.

Обозначим количество маршрутов кузнечика, ведущих в точку с координатой n, как ``K[n]``. Прежде всего заметим, что существует ровно один маршрут из точки 1 в точку 1 — он не содержит ни одного прыжка. В точку 2 можно прыгнуть единственным способом — из точки 1.

Как вычислить ``K[n]``? В точку кузнечик может попасть двумя способами — из точки при помощи прыжка длиной 2 и из точки прыжком длины 1. То есть число способов попасть в точку n равно сумме числа способов попасть в точку (n-1) и (n-2), что позволяет выписать рекуррентное соотношение: ``K[n] = K[n-1] + K[n-2]``.

Можно заметить, что данная задача по сути свелась к числам Фибоначчи, поэтому мы не будем выписывать её решение.

Упражнение №1
+++++++++++++

Решите задачу о количестве способов достичь точки n из точки 1, если кузнечик умеет прыгать +1, +2 и +3.

Упражнение №2
+++++++++++++

Решите задачу о количестве способов достичь точки n из точки 1, если кузнечик умеет прыгать +1, +2 и \*3.

Задача о кузнечике со стоимостями посещения точек
-------------------------------------------------

Пусть кузнечик прыгает на одну или две точки вперед, а за прыжок в каждую точку необходимо заплатить определенную стоимость, различную для различных точек. Стоимость прыжка в точку i задается значением ``price[i]`` списка ``price``. Необходимо найти минимальную стоимость маршрута кузнечика из точки 0 в точку n.

На этот раз нам необходимо модифицировать определение *целевой функции*. Пусть C[n] — минимальная стоимость пути из 1 в n.

Выведем рекуррентное соотношение для этой функции.Чтобы попасть в точку n мы должны попасть в неё последним прыжком из (n-1) или (n-2). Минимальные стоимости этих маршрутов будут равны ``С[n-1]`` и ``С[n-2]`` соответственно, к ним придется добавить значение ``price[n]`` за прыжок в клетку n. Но из двух клеток мы можем выбрать любую.

Нужно выбрать тот маршрут, который имеет наименьшую стоимость: ``C[n] = min(C[n-1], C[n-2]) + price[n]``

Вычислить значение целевой функции также лучше при помощи динамического программирования, а не рекурсии.

Упражнение №3
+++++++++++++

Напишите функцию ``calculate_min_cost(n, price)`` вычисления наименьшей стоимость достижения клетки n из клетки 1

Восстановление наиболее выгодной траектории
-------------------------------------------

Итак, мы нашли список С, где будет записана минимальная стоимость маршрута для всех точек от 1 до n.

Но помимо нахождения наименьшей стоимости маршрута, разумеется, хотелось бы найти и сам маршрут минимальной  стоимости. Такая задача называется задачей «восстановления ответа». 

Для восстановления ответа будем для каждой точки запоминать номер точки ``prev[i]``, из которой кузнечик попал в точку i, если он будет передвигаться по пути минимальной стоимости. То есть ``prev[i]`` — это точка, предшествующая точке с номером i на пути минимальной стоимости (также говорят, что Prev — это массив предшественников). Как определить ``prev[i]``? Если ``C[i-1] < C[i-2]``, то кузнечик попал в точку i из точки (i-1), поэтому ``prev[i] = i - 1``, иначе ``prev[i] = i - 2``.

Для восстановления пути необходимо начать с точки n и переходить от каждой точки к ее предшественнику, пока путь не дойдет до начальной точки с номером 0. Номера всех вершин будем добавлять в список ``path``. В конце в список ``path`` добавляется начальная вершина номер 1, которая не была обработана в основном цикле, а затем весь список ``path`` разворачивается в обратном порядке (т. к. вершины добавляются в обратном порядке, от конечной к начальной).

Упражнение №4
+++++++++++++

Модифицируйте алгоритм вычисления значений целевой функции так, чтобы вычислить значения ``prev[i]``, и восстановите траекторию наименьшей стоимости из точки 1 в точку n.



