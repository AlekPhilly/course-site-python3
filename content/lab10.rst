Объектно-ориентированное программирование
#########################################

:date: 2016-11-02
:lecture_link: https://youtu.be/V2ocqqh0Z_A

.. default-role:: code
.. contents:: Содержание

Основные понятия
================

При процедурном программировании программа разбивается на части в соответствии с алгоритмом: каждая функция является составной частью алгоритма. При объектно-ориентированном программировании программа строится как совокупность взаимодействующих объектов. С точки зрения объектно-ориентированного подхода, объект - это нечто, обладающее значением (состоянием), типом (поведением) и индивидуальностью. Когда программист выделяет объекты в предметной области, он обычно абстрагируется от большинства их свойств, концентрируясь на существенных для задачи свойствах. Над объектами можно производить операции (посылая им сообщения). В языке Python все данные представлены в виде объектов. Взаимодействие объектов заключается в вызове методов одних объектов другими. Иногда говорят, что объекты посылают друг другу сообщения. Сообщения -это запросы к объекту выполнить некоторые действия. (Сообщения, методы, операции, функции-члены являются синонимами).

Каждый объект хранит свое состояние (для этого у него есть атрибуты) и имеет определенный набор методов (функций, обеспечивающих доступ к значениям атрибутов и производящих манипуляции с ними). Методы определяют поведение объекта. Объекты класса имеют общее поведение. Объекты описываются не индивидуально, а с помощью классов. Класс - объект, являющийся шаблоном объекта. Объект, созданный на основе некоторого класса, называется экземпляром класса. Все объекты определенных пользователем классов являются экземплярами класса. Тем не менее, объекты даже с одним и тем же состоянием могут быть разными объектами. Говорят, что они имеют разную индивидуальность.

В языке Python для определения класса используется оператор class:

.. code-block:: python

        class имя_класса(класс1, класс2, ...):
            # определения методов

Класс определяет тип объекта, то есть его возможные состояния и набор операций.

Определим простейший класс:

.. code-block:: python

        >>> # Пример самого простейшего класса
        class MyFirstClass:
            pass

Теперь мы можем создать несколько обьектов этого класса:

.. code-block:: python

        >>> a = MyFirstClass()
        >>> b = MyFirstClass()
        >>> a.val = 1  # у экземпляра a появился атрибут val, равный 1
        >>> b.val = 2  # а у экземпляра b - атрибут val, равный 2
        >>> print(a.val)
        1
        >>> a.val1 = 10  # у экземпляра a появился атрибут val1, равный 10
        >>> b.val2 = 20  # а у экземпляра b - атрибут val2, равный 20

Далее, добавим к нашему классу метод:

.. code-block:: python

        >>> class MyFirstClass:
                def doSmth(self): # self - обязательный аргумент, содержащий в себе экземпляр
                                  # класса, передающийся при вызове метода,
                                  # поэтому этот аргумент должен присутствовать
                                  # во всех методах класса.
                    return 'hello world'

        >>> a = MyFirstClass()
        >>> a.doSmth()
        'hello world'

Перепишем класс немного иначе:

.. code-block:: python

        >>> class MySecondClass:
                def __init__(self):
                    self.msg = 'Hello' # Все экземпляры этого класса будут иметь атрибут msg,
                                       # равный "Hello"
                                       # Но впоследствии мы его можем изменить
                def doSmth(self):
                    return self.msg

        >>> b = MySecondClass()
        >>> b.doSmth()
        'Hello'
        >>> MySecondClass.doSmth(b)
        'Hello'
        >>> b.msg = 'Good by'
        >>> b.doSmth()
        'Good by'

Использование классов дает нам прежде преимущества абстрактного подхода в программировании:

Наследование
 Можно создавать специализированные классы на основе базовых. Это позволяет нам избегать написания повторного кода. На практике часто возникает ситуация, когда в предметной области выделены очень близкие, но вместе с тем неодинаковые классы. Одним из способов сокращения описания классов за счет использования их сходства является выстраивание классов в иерархию. В корне этой иерархии стоит базовый класс, от которого нижележащие классы иерархии наследуют свои атрибуты, уточняя и расширяя поведение вышележащего класса. Обычно принципом построения классификации является отношение "IS-A" ("ЕСТЬ"). Например, класс Окружность в программе - графическом редакторе может быть унаследован от класса Геометрическая Фигура. При этом Окружность будет являться подклассом (или субклассом) для класса Геометрическая Фигура, а Геометрическая Фигура - надклассом (или суперклассом) для класса Окружность. В языке Python во главе иерархии ("новых") классов стоит класс object. Для ориентации в иерархии существуют некоторые встроенные функции, которые будут рассмотрены ниже. Функция issubclass(x, y) может сказать, является ли класс x подклассом класса y:

.. code-block:: python

        >>> class A(object): pass
        >>> class B(A): pass
        >>> issubclass(A, object)
        True
        >>> issubclass(B, A)
        True
        >>> issubclass(B, object)
        True
        >>> issubclass(A, str
        False
        >>> issubclass(A, A) # класс является подклассом самого себя
        True

В основе построения классификации всегда стоит принцип, играющий наиболее важную роль в анализируемой и моделируемой системе. Следует заметить, что одним из "перегибов" при использовании ОО методологии является искусственное выстраивание иерархии классов. Например, не стоит наследовать класс Машина от класса Колесо (внимательные заметят, что здесь отношение другое: колесо является частью машины). Класс называется абстрактным, если он предназначен только для наследования. Экземпляры абстрактного класса обычно не имеют большого смысла. Классы с рабочими экземплярами называются конкретными.

Множественное наследование
 В языке Python можно наследовать класс от нескольких классов. Такая ситуация называется множественным наследованием (multiple inheritance). Класс, получаемый при множественном наследовании, объединяет поведение своих надклассов, комбинируя стоящие за ними абстракции. Использовать множественное наследование следует очень осторожно, а необходимость в нем возникает реже одиночного.

Полиморфизм
 В компилируемых языках программирования полиморфизм достигается за счёт создания виртуальных методов, которые в отличие от невиртуальных можно перегрузить в потомке. В Python все методы являются виртуальными, что является естественным следствием разрешения доступа на этапе исполнения. (Следует отметить, что создание невиртуальных методов в компилируемых языках связано с меньшими накладными расходами на их поддержку и вызов).

.. code-block:: python

        >>> class Parent(object):
                def isParOrPChild(self) : return True
                def who(self) : return 'parent'
        >>> class Child(Parent):
                def who(self): return 'child'
        >>> x = Parent()
        >>> x.who(), x.isParOrPChild()
        ('parent', True)
        >>> x = Child()
        >>> x.who(), x.isParOrPChild()
        ('child', True)

Явно указав имя класса, можно обратиться к методу родителя (как впрочем и любого другого объекта).

.. code-block:: python

        >>> class Child(Parent):
                def __init__(self):
                    Parent.__init__(self)

В общем случае для получения класса-предка применяется функция super.

.. code-block:: python

        class Child(Parent):
            def __init__(self):
                super(Child, self).__init__()

Инкапсуляция
 Можно скрыть ненужные внутренние подробности работы объекта от окружающего мира. Это второй основной принцип абстракции. Он основан на использовании атрибутов внутри класса. Атрибуты могут иметь различные состояния в промежутках между вызовами методов класса, вследствие чего сам объект данного класса также получает различные состояния — state. Подчеркивание (" _ ") в начале имени атрибута указывает на то, что он не входит в общедоступный интерфейс. Обычно применяется одиночное подчеркивание, которое в языке не играет особой роли, но как бы говорит программисту: "этот метод только для внутреннего использования". Двойное подчеркивание работает как указание на то, что атрибут - приватный. При этом атрибут все же доступен, но уже под другим именем, что и иллюстрируется нижe:

.. code-block:: python

        >>> class X:
                x = 0
                _x = 0
                inix = 0
        >>> dir(X)
        ['_X__x', '__doc__', '__module__', '_x', 'x']

Композиция
 Объект может быть составным и включать в себя другие объекты.

Объектно-ориентированный подход в программировании подразумевает следующий алгоритм действий:

* Описывается проблема с помощью обычного языка с использованием понятий, действий, прилагательных.
* На основе понятий формулируются классы.
* На основе действий проектируются методы.
* Реализуются методы и атрибуты.

Поля и методы
=============

Таким образом, объекты классов представляют собой новые типы данный, объединяющие несколько атрибутов (полей). Атрибуты могут быть произвольными типами данных: числами, строками, списками, множествами, словарями, другими классами. Обращение к атрибуту какого-либо объекта осуществляется при помощи dot-нотации: имя_класса.имя_атрибута.

Помимо полей у классов бывают методы: функции, которые можно применять к экземплярам класса. Например, у списков есть метод sort. Вызов метода также осуществляется при помощи dot-нотации, например: A.sort().

Можно рассматривать методы, как функции, у которых первым параметром является экземпляр класса (self). Методы так и объявляются: как функции внутри описания класса, первым параметром которой является экземпляр класса. Вот пример объявления класса Person и метода print, выводящего информацию о полях name и score:

.. code-block:: python

        class Person:
            def print(self):
                print(self.name, self.score)

Теперь вызов метода print для объекта класса Person реализоывается следующим образом:

.. code-block:: python

        p = Person()
        p.print()

При этом не нужно задавать первый параметр self: в качестве этого параметра автоматически будет передан объект, для которого был вызван метод.

Методы могут принимать дополнительные параметры, как и обычные функции. Эти параметры описываются после параметра self:

.. code-block:: python

        class Person:
            def print(self,msg):
                print(self.name, self.score, msg)

Стандартные методы
==================

Наш метод print предполагает, что у объекта есть поля name и score, иначе он завершится с ошибкой. Хочется быть уверенным, что у любого объекта класса Person есть эти поля. Для этого проще всего создать эти поля при создании объекта, т.е. при вызове функции Person. Для этого можно использовать конструктор: метод, который автоматически вызывается при создании объекта. Конструктором является метод с именем __init__:

.. code-block:: python

        class Person:
            def __init__(self):
                self.name = ''
                self.score = 0

При создании объекта функцией Person будет автоматически вызван конструктор __init__ (явно вызывать его не нужно), который полю name объекта, для которого он вызван, присвоит пустую строку, а полю score присвоит значение 0.

Удобно будет, если конструктор сможет создавать объект, инициализируя поля объекта некоторыми параметрами, используя передаваемые ему значения, а не значения по умолчанию. Для этого конструктору можно передавать параметры:

.. code-block:: python

        class Person:
            def __init__(self, name, score):
                self.name = name
                self.score = score

В данном случае мы используем одинаковые имена (name, score) для обозначения передаваемых параметров и полей класса. Это сделано для удобства — имена могут и различаться.

Теперь мы сможем создавать новый объект с заданными полями так: Person('Иванов', 5).

Но поскольку конструктор теперь обязательно принимает два дополнительных параметра мы лишились возможности вызывать конструктор без параметров, что также бывает удобно. Можно вернуть эту особенность, если установить для параметров, передаваемых конструктору, значения по умолчанию:

.. code-block:: python

        class Person:
            def __init__(self, name = '', score = 0):
                self.name = name
                self.score = score

Теперь мы можем вызывать конструктор как с параметрами (Person('Иванов', 5)), так и без параметров (Person()), в последнем случае параметрам будут переданы значения “по умолчанию”, указанные в описании конструктора. Также существует метод, вызываемый при унчитожении обьекта - деструктор (__del__):

.. code-block:: python

        class Person:
            def __init__(self, name = '', score = 0):
                self.name = name
                self.score = score

            def __del(self):
                print "Object %s has been destoyed" % self.name

Есть и другие стандартные методы, которые можно определить в описании класса.

Метод __repr__ должен возвращать текстовую строку, содержащую код (на языке Python), создающую объект, равный данному. Естественно, метод __repr__ должен содержать вызов конструктора, которому передаются в качестве параметров все строки исходного объекта, то есть он должен возвращать строку вида "Person('Иванов', 5)"

Пример метода __repr__ (для экономии места опустим описание конструктора __init__):

.. code-block:: python

        class Person:
            def __repr__(self):
                return "Person('" + self.name + "', " + self.score + ")"

Таким образом, метод __repr__ возвращает строку с описанием объекта, которое может быть воспринято итерпретатором языка Питон.

Метод __str__ возвращает строку, являющуюся описанием объекта в том виде, в котором его удобно будет воспринимать человеку. Здесь не нужно выводить имя конструктора, можно, например, просто вернуть строку с содержимым всех полей:

.. code-block:: python

        class Person:
            def __str__(self):
                return self.name + ' ' + str(self.score)

Метод __str__ будет вызываться, когда вызывается функция str от данного объекта, например, str(Vasya). То есть создавая метод __str__ вы даете указание Питону, как преобразовывать данный объект к типу str.

Поскольку функция print использует именно функцию str для вывода объекта на экран, то определение метода __str__ позволит выводить объекты на экран удобным способом: при помощи print.

Упражнения - игра "Пушка"
=========================

Упражнение №1
+++++++++++++
Команда студентов начала разрабатывать игру "Пушка". Для тестирования использовался обфусцированный исходный файл, который позволяет увидеть процесс, но скрывает исходный код: `obfuscated`_

.. _obfuscated: {filename}/code/lab10/gun_obfuscated.py

В результате празднования окончания сессии компьютер, на котором лежали работающие исходники, был испорчен. На флешке была найдена только промежуточная версия. 
Помогите восстановить работоспособность программы используя имеющийся исходный код: `gunsource`_

.. _gunsource: {filename}/code/lab10/gun.py

Подсказка: для начала, исправте код так, чтобы он запускался, и поправте все 'FIXME'.

Упражнение №2
+++++++++++++
Улучшите программу из п.6 добавив 2 цели.

Упражнение №3
+++++++++++++
Улучшите программу из п.7 сделав цели движущимися.

Переопределение стандартных операций
====================================

Рассмотрим класс Vector, используемый для представления радиус-векторов на координатной плоскости, и определим в нем поля-координаты: x и y. Также очень хотелось бы определить для векторов операцию +, чтобы их можно было складывать столь же удобно, как и числа или строки. Например, чтобы можно было записать так:

.. code-block:: python

        A = Vector(1, 2)
        B = Vector(3, 4)
        C = A + B

Для этого необходимо перегрузить операцию +: определить функцию, которая будет использоваться, если операция + будет вызвана для объекта класса Vector. Для этого нужно определить метод __add__ класса Vector, у которого два параметра: неявная ссылка self на экземпляр класса, для которого она будет вызвана (это левый операнд операции +) и явная ссылка other на правый операнд:

.. code-block:: python

        class Vector:
            def __init__(self, x = 0, y = 0):
                self.x = x
                self.y = y
            def __add__(self, other):
                return Vector(self.x + other.x, self.y + other.y)

Теперь при вызове оператора A + B Питон вызовет метод A.__add__(B), то есть вызовет указанный метод, где self = A, other = B.

Аналогично можно определить и оставшиеся операции. Полезной для переопределения является операция <. Она должна возвращать логическое значение True, если левый операнд меньше правого или False в противном случае (также в том случае, если объекты равны). Для переопределения этого операнда нужно определить метод __lt__ (less than):

.. code-block:: python

        class Vector:
            def __lt__(self, other):
                return self.x < other.x or self.x == other.x and self.y < other.y

В этом примере оператор вернет True, если у левого операнда поле x меньше, чем у правого операнда, а также если поля x у них равны, а поле y меньше у левого операнда.

После определения оператора <, появляется возможность упорядочивать объекты, используя этот оператор. Теперь можно сортировать списки объектов при помощи метода sort() или функции sorted, при этом будет использоваться именно определенный оператор сравнения <.

Функции type и isinstance
=========================

Полезно, чтобы конструктор __init__ мог воспринимать параметры различных типов. Например, удобно инициализировать вектор не только двумя числами, но и строкой, в которой через пробел записаны два числа (такая строка может быть считана со стандартного ввода), списком или кортежем. То есть передаваемые конструктору аргументы могут быть разного типа (int, float, str, list, tuple). Конструктор должен выполнять различные действия для параметров различного типа, для этого нужно уметь проверять принадлежность объекту какому-либо классу.

Эту задачу можно решить при помощи функций type и isinstance. Функция type возвращает класс, к которому принадлежит объект. Например:

.. code-block:: python

        if type(a) == int:
            print('a -  целое число')
        elif type(a) == str:
            print('a - строка')

Для этого можно использовать функцию isinstance, у которой два параметра: объект и класс. Функция возращает True, если объект принадлежит классу или False в противном случае. Пример:

.. code-block:: python

        if isinstance(a, int):
            print('a -  целое число')
        elif isinstance(a, str):
            print('a - строка')

Список возможных перегружаемых операторов

Следующая таблица взята из книги Саммерфильда (стр. 283 и далее).

+---------------------------------+------------------+
| Метод                           | Использование    |
+=================================+==================+
| Операторы сравнения                                |
+---------------------------------+------------------+
| __lt__(self, other)             | x < y            |
+---------------------------------+------------------+
| __le__(self, other)             | x <= y           |
+---------------------------------+------------------+
| __eq__(self, other)             | x == y           |
+---------------------------------+------------------+
| __ne__(self, other)             | x != y           |
+---------------------------------+------------------+
| __gt__(self, other)             | x > y            |
+---------------------------------+------------------+
| __ge__(self, other)             | x >= y           |
+---------------------------------+------------------+
| Арифметические операторы                           |
+----------------------------------------------------+
| Сложение                                           |
+---------------------------------+------------------+
| __add__(self, other)            | x + y            |
+---------------------------------+------------------+
| __radd__(self, other)           | y + x            |
+---------------------------------+------------------+
| __iadd__(self, other)           | x += y           |
+---------------------------------+------------------+
| Вычитание                                          |
+---------------------------------+------------------+
| __sub__(self, other)            | x - y            |
+---------------------------------+------------------+
| __rsub__(self, other)           | y - x            |
+---------------------------------+------------------+
| __isub__(self, other)           | x -= y           |
+---------------------------------+------------------+
| Умножение                                          |
+---------------------------------+------------------+
| __mul__(self, other)            | ``x * y``        |
+---------------------------------+------------------+
| __rmul__(self, other)           | ``y * x``        |
+---------------------------------+------------------+
| __imul__(self, other)           | ``x *= y``       |
+---------------------------------+------------------+
| Деление                                            |
+---------------------------------+------------------+
| __truediv__(self, other)        | x / y            |
+---------------------------------+------------------+
| __rtruediv__(self, other)       | y / x            |
+---------------------------------+------------------+
| __itruediv__(self, other)       | x /= y           |
+---------------------------------+------------------+
| Целочисленное деление                              |
+---------------------------------+------------------+
| __floordiv__(self, other)       | x // y           |
+---------------------------------+------------------+
| __rfloordiv__(self, other)      | y // x           |
+---------------------------------+------------------+
| __ifloordiv__(self, other)      | x //= y          |
+---------------------------------+------------------+
| __divmod__(self, other)         | divmod(x, y)     |
+---------------------------------+------------------+
| Остаток                                            |
+---------------------------------+------------------+
| __mod__(self, other)            | x % y            |
+---------------------------------+------------------+
| __rmod__(self, other)           | y % x            |
+---------------------------------+------------------+
| __imod__(self, other)           | x %= y           |
+---------------------------------+------------------+
| Возведение в степень                               |
+---------------------------------+------------------+
| __pow__(self, other)            | ``x ** y``       |
+---------------------------------+------------------+
| __rpow__(self, other)           | ``y ** x``       |
+---------------------------------+------------------+
| __ipow__(self, other)           | ``x **= y``      |
+---------------------------------+------------------+
| Отрицание, модуль                                  |
+---------------------------------+------------------+
| __pos__(self)                   | +x               |
+---------------------------------+------------------+
| __neg__(self)                   | -x               |
+---------------------------------+------------------+
| __abs__(self)                   | abs(x)           |
+---------------------------------+------------------+
| Преобразование к стандартным типам                 |
+---------------------------------+------------------+
| __int__(self)                   | int(x)           |
+---------------------------------+------------------+
| __float__(self)                 | float(x)         |
+---------------------------------+------------------+
| __str__(self)                   | str(x)           |
+---------------------------------+------------------+
| __round__(self, digits = 0)     | round(x, digits) |
+---------------------------------+------------------+

Упражнения - класс Vector
=========================

Упражнение №1
+++++++++++++
Создайте класс Vector с полями x и y, определите для него конструктор, метод __str__, необходимые арифметические операции. Реализуйте конструктор, который принимает строку в формате "x,y".

Упражнение №2
+++++++++++++
Программа получает на вход число N, далее координаты N точек. Доопределите в классе Vector недостающие операторы, найдите и выведите координаты точки, наиболее удаленной от начала координат.

Упражнение №3
+++++++++++++
Используя класс Vector выведите координаты центра масс данного множества точек.

Упражнение №4
+++++++++++++
Среди данных точек найдите три точки, образующие треугольник с наибольшим периметром. Выведите данный периметр.

Упражнение №5
+++++++++++++
Среди данных точек найдите три точки, образующие треугольник с наибольшей площадью. Выведите данную площадь.
