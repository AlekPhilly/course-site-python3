Практика: графические примитивы
###############################

:date: 2017-09-22 09:00
:status: draft

.. default-role:: code
.. contents:: Содержание


Введение
========

На этом занятии вы будете рисовать графические объекты на языке Python.

Благодаря `Джону Зелле`__ у нас есть вспомогательная библиотека графики (`graphics.py`), с помощью которой
мы будем отображать примитивные объекты на экране.

.. __: http://mcsp.wartburg.edu/zelle/

Установка и подключение библиотеки
----------------------------------

Нужно `скачать файл`__ и положить в ту (именно в ту) директорию, где вы собираетесь далее писать свои программы.

.. __: http://mcsp.wartburg.edu/zelle/python/graphics.py

Чтобы импортировать возможности библиотеки `graphics` в вашей программе нужно вставить:

.. code-block:: python

    import graphics as gr

Теперь все объекты этой библиотеки будут вызываться через точку: `gr.КакойНибудьОбъект()`.


Обзор команд модуля `graphics`
------------------------------

Графическое окно — это место, где будут размещаться графические примитивы:

.. code-block:: python

    # Инициализация окна с названием "Russian game" и размером 100х100 пикселей
    window = gr.GraphWin("Russian game", 100, 100)

    # Закрытие окна после завершения работы с графикой
    window.close()

Создание графических примитивов:

.. code-block:: python
    
    # Создание круга с радиусом 10 и координатами центра (50, 50)
    myCircle = Circle(Point(50, 50), 10)

    # Создание отрезка с концами в точках (2, 4) и (4, 8)
    myLine = Line(Point(2, 4), Point(4, 8))

    # Создание прямоугольника у которого диагональ — отрезок с концами в точках (2, 4) и (4, 8)
    myRectangle = Rectangle(Point(2, 4), Point(4, 8))
     
Отрисовка примитива в графическом окне производится отдельной командой:

.. code-block:: python

    # Отрисовка примитивов в окне window
    myCircle.draw(window)
    myLine.draw(window)
    myRectangle.draw(window)

Скрипт выполнится крайне быстро и мы не успеем увидеть результаты нашего труда. Чтобы это исправить, стоит поставить выполнение скрипта на паузу:

.. code-block:: python

    #  Ожидание нажатия кнопки мыши по окну.
    window.getMouse()

    #  После того как мы выполнили все нужные операции, окно следует закрыть.
    window.close()

    
Пример программы
----------------
    
Законченный пример, который рисует low-poly изображение человеческого лица:

.. code-block:: python

    from graphics import *

    window = GraphWin("Jenkslex and Ganzz project", 400, 400)

    face = Circle(Point(200, 200), 100)
    face.setFill('yellow')

    eye1 = Circle(Point(150, 180), 20)
    eye2 = Circle(Point(250, 180), 15)
    eye1_center = Circle(Point(150, 180), 8)
    eye2_center = Circle(Point(250, 180), 7)
    eye1.setFill('red')
    eye2.setFill('red')
    eye1_center.setFill('black')
    eye2_center.setFill('black')

    eyebrow1 = Line(Point(100, 120), Point(180, 170))
    eyebrow2 = Line(Point(220, 170), Point(300, 140))
    eyebrow1.setWidth(10)
    eyebrow2.setWidth(10)
    eyebrow1.setOutline('black')
    eyebrow2.setOutline('black')

    mouth = Line(Point(150, 260), Point(250, 260))
    mouth.setWidth(20)
    mouth.setOutline('black')

    face.draw(window)
    eye1.draw(window)
    eye2.draw(window)
    eye1_center.draw(window)
    eye2_center.draw(window)
    eyebrow1.draw(window)
    eyebrow2.draw(window)
    mouth.draw(window)

    window.getMouse()

    window.close()


Скопируйте код в среду разработки, запустите и посмотрите на результат.

Документация
------------

Для выполнения данной работы линий, прямоугольников и кругов вполне достаточно. Но если вы хотите узнать еще больше команд, то `загляните в документацию библиотеки graphics`__.

.. __: http://mcsp.wartburg.edu/zelle/python/graphics/graphics/index.html

Бесструктурное программирование
===============================

Самостоятельное задание №1. Пейзаж
----------------------------------

Используя полученные знания, нарисуйте любую статическую сцену, которая содержит не менее 5 различных объектов, состоящих из пяти и более примитивов. Проявите свою творческую натуру, но не занимайтесь этим более 30 минут, ведь вашу сцену можно улучшать вечно, а наша задача немного в другом. Примером сцены может являться следующая картинка:

.. image:: {filename}/images/lab4/export.png
    :align: center

Сделайте это задание и дождитесь дальнейших указаний преподавателя.

.. image:: {filename}/images/lab4/zhdun.png
    :align: center

Cтруктурное программирование
============================

Давайте изменим нашу программу так, чтобы она была разделена на логические независимые куски кода — функции. 

Приведем пример простой программы, чтобы показать, как работают функции.

.. code-block:: python

    # Определение функции
    def say_hello():
        # Тело функции
        print('Say hello to my little friend!')

    # Вызов функции
    say_hello()

Обратите внимание, что все входящие в тело функции операции должны быть с отступом в четыре пробела. А также на тот факт, что без вызова функции все операции, которые прописаны в теле функции, выполнены не будут.

Функции — мощный инструмент. Идея в том, чтобы разделить наш код на независимые друг от друга по смыслу куски.

Дейкстра пишет, что ни один человек не обладает интеллектом, способным вместить все детали современной компьютерной программы, поэтому нам не стоит пытаться охватывать всю программу сразу. Вместо этого мы должны попытаться организовать программы так, чтобы можно было безопасно работать с их отдельными фрагментами по очереди.

Целью этого является минимизация обьема программы, о котором нужно думать в конкретный момент времени. Можно считать это своеобразным умственным жонглированием: чем больше умственных шаров программа заставляет поддерживать в воздухе, тем выше вероятность того, что вы уроните один из них и допустите ошибку при кодировании.

Пока объем вашего кода не достигает 100 строк, вы можете без проблем ориентироваться в нём. Как только цифра возрастет на порядок, вы потеряетесь в своей программе и не сможете вообще ничего сделать.

Продемонстрируем как правильно использовать функции:

.. code-block:: python

    from graphics import *

    window = GraphWin("Jenkslex and Ganzz project", 400, 400)

    def drawLeftEye():
        eye     = Circle(Point(150, 180), 20)
        pupil     = Circle(Point(150, 180), 10)

        eye.setFill('red')
        pupil.setFill('black')

        eye.draw(window)
        pupil.draw(window)

    def drawRightEye():
        eye     = Circle(Point(250, 180), 14)
        pupil     = Circle(Point(250, 180),  7)

        eye.setFill('red')
        pupil.setFill('black')

        eye.draw(window)
        pupil.draw(window)

    def drawEyebrows():
        eyebrow1 = Line(Point(100, 120), Point(180, 170))
        eyebrow2 = Line(Point(220, 170), Point(300, 120))

        eyebrow1.setWidth(10)
        eyebrow2.setWidth(10)

        eyebrow1.setOutline('black')
        eyebrow2.setOutline('black')

        eyebrow1.draw(window)
        eyebrow2.draw(window)

    def drawFace():
        face = Circle(Point(200, 200), 100)
        face.setFill('yellow')

        face.draw(window)

    def drawMouth():
        mouth = Line(Point(150, 260), Point(250, 260))
        mouth.setWidth(20)
        mouth.setOutline('black')

        mouth.draw(window)

    def drawTimofeyFedorovich():
        drawFace()
        drawLeftEye()
        drawRightEye()
        drawEyebrows()
        drawMouth()


    drawTimofeyFedorovich()

    window.getMouse()

    window.close()

    
Как видите, функциональность программы не изменилась, но если вы увидете ее в первый раз, вы разберетесь с ней гораздо быстрее, чем если бы вы разбирались с первоначальным примером, написанным без использования функций.


Самостоятельное задание №2
--------------------------

Измените вашу сцену так, чтобы какой-нибудь обьект был нарисован на сцене два раза, в двух разных местах. Например, два домика.



Функции с параметрами
=====================

А теперь представьте, что в предыдущей самостоятельной работе вас попросили сделать не две копии, а сто?

Наивным решением будет написать сто почти одинаковых функций с измененными цифрами, но если мы вдруг внезапно захотим во всех этих обьектах убрать какой-либо примитив — нам придется залезть в каждую такую функцию и изменить соответствующие строчки.

Такой подход абсолютно нежизнеспособен. 

Рациональным выходом из подобной ситуации будет являться использование функций с параметрами. В физике положение обьекта мы задавали с помощью координат, почему бы такой подход не распространить и на графические обьекты?

В примере, где демонстрируется рисование смайлика, у нас есть два глаза, код отрисовки которых почти ничем не отличается, кроме использования трех чисел: положения в пространстве и размер.

Продемонстрируем, как этот код можно оптимизировать.

.. code-block:: python

    def drawEye(x, y, size):
        eye     = Circle(Point(x, y), size)
        pupil     = Circle(Point(x, y), size/2)

        eye.setFill('red')
        pupil.setFill('black')

        eye.draw(window)
        pupil.draw(window)

    def drawTimofeyFedorovich():
        drawFace()
        drawEye(150, 180, 20)
        drawEye(250, 180, 14)
        drawEyebrows()
        drawMouth()

Как видите теперь, если мы хотим изменить конструкцию обоих глаз одновременно, нам достаточно изменить код в одном месте, и это изменение распространиться на все обьекты, которые отрисовываются данной функцией.

Самостоятельное задание №3
--------------------------

Используя функции с параметрами оптимизируйте свой код, который отрисовывал два обьекта из предыдущего задания.

Если при разработке вы встречаетесь с ситуацией, когда в коде присутствуют две последовательности действий, которые отличаются совсем немного — лучше обощить их и написать одну общую функцию с параметрами, которая в зависимости от входных данных, будет решать разные задачи.

Это одна из самых важных вещей в программировании — разделять программу на модульные абстракции.
Это не просто и на эту тему написано достаточно много книг, однако первый шаг в этом направлении вы уже сделали.
По возможности старайтесь находить элегантные решения. Это поможет вам сэкономить уйму времени в будущем.