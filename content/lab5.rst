Практика: физическое моделирование
##################################

:date: 2017-09-29 09:00
:status: draft

.. default-role:: code
.. contents:: Содержание


Введение
========

В прошлый раз мы с вами научились отрисовывать объекты на экран и освоили такой важный инструмент, как функции.

На этом занятии ваше погружение в gamedev продолжится и вы узнаете, как правильно описать физику и логику програмным языком и как связать все эти компоненты воедино.

Не забудьте, что для работы с графикой у вас есть вспомогательная библиотека (`graphics.py`),
с помощью которой вы будете отображать объекты на экране.
Нужно `скачать её`__ и положить в ту (именно в ту) директорию, где вы собираетесь далее писать свои программы.

.. __: {filename}/extra/lab4/graphics.py


Моделирование движения материальной точки
-----------------------------------------

Равномерное движение
++++++++++++++++++++

Подключим библиотеку дял работы с графикой.

.. code-block:: python
    import graphics as gr

    SIZE_X = 400
    SIZE_Y = 400

    window = gr.GraphWin("Model", SIZE_X, SIZE_Y)  

Начнём мы с такой простенькой задачки. Нужно смоделировать равномерное движение шарика на плоскости. Как же мы это будем делать?

Начнём с описания физической модели. Для моделирования такого процесса, нам достаточно знать 2 физические характеристики шарика: это его положение в пространстве и направление скорости.

.. code-block:: python
    #  Начальное положение шарика
    coords = gr.Point(200, 200)
    #  Скорость
    velocity = gr.Point(1, -2)

Вероятно, вас смущает, что скорость мы описываем с помощью понятия "точка". На самом деле, это абсолютно оправдано, поскольку скорость есть вектор из плоскости. 
Это гораздо лучше, чем отдельно хранить скорость по x и скорость по y, поскольку подход позволит нам тянуть за собой не две переменные, а всего лишь одну (просто вектор из R^2). 
Соответственно, нам придётся меньше держать в голове.

Симуляция материальной точки представляет собой непрерывный процесс пересчёта координат по заданным нами законам. 
Поскольку сейчас мы моделируем обычное равномерное движение, законы пересчёта будут очень просты.

X_{k+1} = X_k + V*t

Давайте будем считать, что t равно 1. Тогда все моменты времени отличаются ровно на 1. 
В таком случае, чтобы получить значения координат в следующий момент времени, нужно к текущим координатам прибавить скорость.
Напишем сразу функцию, которая будет возвращать сумму двух векторов.

.. code-block:: python

    def add(point_1, point_2):
        new_point = Point(point_1.x + point_2.x,
                          point_1.y + point_2.y)

        return new_point

Эта функция поможет нам не заморачиваться каждый раз по поводу оперции сложения двух векторов и позволит сфокусироваться на более высокоуровневых вещах.

Процесс отрисовки шарика также лучше вынести на отдельный уровень абстракции и оформить в функцию.

.. code-block:: python

    def draw_circle(coords):
        circle = gr.Circle(coords, 10)
        circle.setFill('red')

        circle.draw(window)

Теперь мы вплотную подошли к процессу моделирования и визуализации. 
Сначала мы рассчитываем координаты шарика, а после отрисовываем его в полученных координатах. И так по кругу, пока мы не захотим прервать этот процесс закрытие окна.

.. code-block:: python

    while True:
        draw_circle(coords)
        coords = add(coords, velocity)

.. image:: {filename}/images/lab5/1.png
    :align: center

Как видим, мы столкнулись с двумя проблемами. Первое - вся сцена рисуется мгновенно, никаких промежуточных результатов мы не видим, было бы неплохо добавить задержку между кадрами, 
чтобы мы могли наблюдать эволюцию системы. Второе - мы видим, что на экране остаются изображения шариков в предыдущие моменты времени, от этого артефакта мы бы тоже хотели избавиться.

Давайте напишем функцию, которая очищает экран.

.. code-block:: python
    def clear_window():
        rectangle = gr.Rectangle(gr.Point(0, 0), gr.Point(SIZE_X, SIZE_Y))
        rectangle.setFill('green')
        rectangle.draw(window)

А в основном цикле пропишем команду, которая усыпляет выполнение скрипта на какое то небольшое время

Весь написанный нами пример можно посмотреть 'здесь'__.

.. __: {filename}/code/lab5/1.py

Отражение от стенок
+++++++++++++++++++

Давайте усовершенствем нашу модель. В течение двух секунд шарик покидает область экрана и теряем возможность за ним наблюдать. 
Для решения этой проблемы добавим упругое отражение шарика от стенок экрана. Это делается очень простым образом. 
В теле основного цикла добавим функцию, которая будет проверять столкновение, и, в случае такого события, инвертировать скорость шарика по нужной оси.

.. code-block:: python
    def check_coords(coords, velocity):
        if coords.x < 0 or coords.x > SIZE_X:
            velocity.x = -velocity.x

        if coords.y < 0 or coords.y > SIZE_Y:
            velocity.y = -velocity.y

.. code-block:: python
    while True:
        clear_window()
        draw_ball(coords)
        coords = add(coords, velocity)

        check_coords(coords, velocity)

        gr.time.sleep(0.02)

Весь код 'здесь'__. 

.. __: {filename}/code/lab5/2.py

Равномерная сила тяжести (Равноускоренное движение)
+++++++++++++++++++++++++++++++++++++++++++++++++++

Центральная сила тяжести (спутник возле солнца)
+++++++++++++++++++++++++++++++++++++++++++++++

Математический маятник
++++++++++++++++++++++

Сравнение мат.маятника с уравнением (отображение двумя картинками)

	
Игра "Пушка"
------------

Команда студентов начала разрабатывать игру "Пушка". Для тестирования использовался обфусцированный исходный файл, который позволяет увидеть процесс, но скрывает исходный код: `obfuscated`_

.. _obfuscated: {filename}/code/lab5/gun_obfuscated.py

В результате празднования окончания сессии компьютер, на котором лежали работающие исходники, был испорчен. На флешке была найдена только промежуточная версия. 
Помогите восстановить работоспособность программы используя имеющийся исходный код: `gunsource`_

.. _gunsource: {filename}/code/lab5/gun.py


Игра "поймай мяч"
-----------------

Событийное программирование. Ловим событие от мышки handler-ом асинхронно.

