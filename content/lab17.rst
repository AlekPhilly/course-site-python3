Разработка игры "Pacman"
########################

:date: 2016-01-21

.. default-role:: code
.. contents:: Содержание

Введение
========

Целью текущего и следующего занятий будет знакомство с библиотекой pygame и разработка игры PacMan 

Игровой процесс
---------------

Пакман – игровое существо, похожее на колобка, способное перемещаться по лабиринту, разрушать некоторые стенки и поедать артифакты.
Цель игры – сьесть все белые точки на уровне и избежать столкновения с привиденями. Помимо точек на уровне могут находится другие сьедобные артифакты, за поедание которых начисляются дополнительные очки.  Некоторые из них могут быть замурованы в стены. 
Стены уровня бывают двух типов – разрушаемые и неразрушаемые. Разрушать стены может только Пакман.
Приведения перемещаются вдоль стен со скоростью близкой к скорости Пакмана, и на перекрестках случайным образом принимают решение куда продолжать движение. Количество привидений зависит от сложности уровня. 

Улучшения игры:

Артифакты могут не только давать больше количество очков по сравнению с точками, но и наделать пакмана волшебными свойствами (при этом обладание волшебстввом должно визуально отображаться, например изменением цвета пакмана), например такими:

1. Ускорение. В  течение некоторого времени Пакман двигается быстрее.
2. Возможность проламывать неразрушаемые стены. При этом стены по периметру лабиринта разрушить нельзя.
3. Выживание в случае со встречей с приведением. (Тут может быть как и действие по времени, так и до первой встречи)
4. Режим невидимки – в случае если в модели перемещения привидений реализовано движение в сторону пакмана, то на некоторое время они становятся “слепыми”

Приведения могут быть нескольких типов:

1. Бестолковые – перемещающиеся вдоль стен и случайно поворачивающие на перекрестках
2. С зрением – если находятся с Пакманом на одной линии то начинают двигаться за ним и при этом “помнят” куда он повернул на перекрестке. Если не Пакмана нет в поле зрения то двигаются как в п.1

Первоначальное расположение пакмана и приведений может быть как задано на карте так и при каждом старте уровня определяться случайным образом.

Карта
-----

Карта представляет собой текстовый файл, в котором каждый символ описывает одну клетку игрового пространства. Например:
X – наразрушаемая стена
O – разрушаемая стена
. – точка которую нужно сьесть Пакману (могут быть не во всех свободных клетках), также могут быть замурованы в разрушаемые стены
1-9 – “волшебные” артифакты. Могут располагаться как на открытых участках лабиринта, так и быть замурованы в стены.

Библиотека PyGame
=================

PyGame – библиотека, для написания игр на языке Python. Поддерживается работа с 2D/3D и существует возможность подключать сторонние графические и физические движки.
Программа HelloWorld с использованием PyGame выглядит следующим образом:
import pygame
 
.. code-block:: python
	import pygame
	from pygame.locals import *

	pygame.init() # Инициализируем библиотеку
	window = pygame.display.set_mode((640, 480)) # Задаем размеры окошка
	pygame.display.set_caption('Hello world') # Задаем загаловок окошка


В данном примере окошко исчезает сразу после появления. Следующий шаг – добавим цикл, принимающий и обрабатывающий собщения:

.. code-block:: python
	import sys
	import pygame
	from pygame.locals import *
 
	def init_window():
		pygame.init()
    		pygame.display.set_mode((640, 480))
    		pygame.display.set_caption('Hello world 2')
 
	# В функции описывается логика поведения приложения на события, генерируемые пользователем

	def process_events(events):
		for event in events:
			# Если был клик на кнопке закрытия окна или нажата клавиша Eвс завершаем процесс
		        if (event.type == QUIT) or (event.type == KEYDOWN and event.key == K_ESCAPE):
		            sys.exit(0)
 
	def main():
		# Инициализируем окно приложения
		init_window()
    
		# В бесконечном цикле принимаем и обрабатываем сообщения
		while 1:
			process_events(pygame.event.get())
 
	if __name__ == '__main__': main()

После инициализации приложения добавляется бесконечный цикл, принимающий и обрабатывающий сообщения от клавиатуры и мыши. В данном случае приложение завершает свою работу при нажатии на кнопку закрытия окна или клавишу Esc.

Далее загрузим из файла и выведем на экран фоновое изображение и персонажа. 
Чтобы не было мерцания экрана в процессе перерисовок, обычно применяется метод рисования на скрытые поверхности: при инициализации окна создается два буфера, один из которых отображается в окне, а во второй осуществляется рисование. Как только отрисовка сцены закончена, буфера меняются местами посредством вызова функции flip().
Отрисовку фона зададим функцией:

.. code-block:: python
	back = pygame.image.load("background.png") # загружаем фоновую картинку

	def draw_background():
		screen = pygame.display.get_surface() # Получаем поверхность, на которой будем рисовать
		background = pygame.Surface(screen.get_size()) # и ее размер
		background = background.convert()
		background.fill((0, 0, 0)) # заполняем цветом
		screen.blit(background, (0, 0)) # рисуем заполненный одним цветом бэкграунд
    		screen.blit(back, (0, 0)) # и рисуем ее
		return back

Для более удобных манипуляций с изображениями игровых персонажей существует класс pygame.sprite.Sprite. Создадим базовый класс для персонажей игры:

.. code-block:: python	

	class GameObject(pygame.sprite.Sprite):
		def __init__(self, img, x, y):
			pygame.sprite.Sprite.__init__(self)
			self.image =  pygame.image.load(img)
			self.rect = self.image.get_rect()
			screen = pygame.display.get_surface()
			self.area = screen.get_rect()
			self.x = x
			self.y = y
			self.coord = (x, y)

и класс конкретного героя:

.. code-block:: python	

	class Monster(GameObject):
		def __init__(self, cX, xY):
			GameObject.__init__(self, cX, cY, “./resourses/monster.png”)


В данном примере примере координаты игрового обьекта задаются в пикселях относительно левого верхнего угла экрана. Поскольку игровое поле разбито на квадраты одинакового размера (тайлы) то в “игровом мире” удобее использовать тайловую систему координат.
Перевод координат их игровой в экранную осуществляется по формуле:

	Хэкр = размер тайла * Xигр
	Yэкр = размер тайла * Yигр

Поскольку игровому процессу актуальны координаты на игровом поле а не на экране, перепишем класс GameObject:

.. code-block:: python	
	class GameObject(pygame.sprite.Sprite):
		def __init__(self, img, x, y, tile_size):
			pygame.sprite.Sprite.__init__(self)
			self.image =  pygame.image.load(img)
			self.rect = self.image.get_rect()
			screen = pygame.display.get_surface()
			self.area = screen.get_rect()
			self. tile_size = tile_size
			set_coord(x, y)

		def get_coord():
			return (self.x,self.y)

		def get_normalized_coord():
			return (floor(self.x), floor(self.y))

		def set_coord(x,y)
			self.x = x
			self.y = y
			self.coord = (floor(x) * tile_size, floor(y) * tile_size)
    
    
В играх время течет дискретно, и измеряется в тиках (tick). Если обьект перемещается с некоторой скоростью, то координата будет выражатся по формуле x = x0 + v * n, где n = 0, 1, 2,… Для того чтобы обьект переместился на 1 клетку за 10 тиков, его скорость должна равняться 1/10, а координата будет принимать дробные значения. Номер позиции тайла на игровом поле будет равен floor(x). Иначе говоря, координаты обьекта на игровом поле могут принимать вещественные значения, в которых целая часть определяет столбец/строку в которой должен быть отрисован тайл.
     
Обьеденим вышесказанное воедино, и получим игровой персонаж и элемент стены на фоне.

.. code-block:: python	

	TBD

Для описания игрового поля можно использовать двумерный массив, каждый элемент которого описывает обьект, находящийся в данной клетке. Данный подход хорош ровно до того момента, пока не появится два персонажа, которые могут одновременно находится в одном месте игрового поля. Например – два приведения, движущиеся навстречу друг другу. Поэтому для описания игрового мира проще всего использовать двухмерный массив например списков. 
В начальный момент в массиве содержится карта, загруженная из файла. Опишем карту в виде класса Map:

.. code-block:: python	

	class Map:
		def __init__(self, w, h):
			self.map = [ [list()]*x for i in range(y) ]
	
		# Функция возвращает список обьектов в данной точке карты
		def get(self, x, y):
			return self.map[x][y]

		# Функция перемещающая произвольный обьект в новую точку тогда будет выглядеть так:
		def moveTo(self, obj, new_x, new_y):
			point = self.map[obj.x][obj.y]
			if obj in point:
				point.remove(obj)
				self.map[new_x][new_y].add(obj)
				obj.set_ccord(x,y)
				return true
			return false

		#Метод, осущеставляющий отрисовку всего игрового поля, реализуется следующим образом:
		def drawAll(self):
			# TODO


Пакман перемещается по игровому полю только когда игрок нажимает соотвуствующую клавишу. Приведения же двигаются сами все время. 
Это достигается модификацией бесконечного цикла, обрабатывающего сообщения:

.. code-block:: python	

	while 1:
		process_events(pygame.event.get()) # Обрабатываем игровые события
		move_ghosts()   # функция которая перемещает приведения по карте
		pygame.time.delay(100) #задержка в 100 мс

Задание:

1) Склонируйте в свой репозиторий классы, описанные выше

2) Добавьте неразрушаемые стены на карту, убедитесь что пакман сквозь них не проходит и не разрушает

3) Добавьте приведение, реализуйте случайную модель поведения.

4) Добавьте добавьте второе приведение, убедитесь что они корректно могут проходить друг сквозь друга.

5) Реализуйте загрузку карты из файла

6) Добавите на карту точки, которые пакман должен сьесть, и завершение игры когда точек более не осталось.







