Тестирование программ
#####################

:date: 2015-10-03 21:30
:Status: draft

.. default-role:: code
.. contents:: Содержание


Тестирование: зачем оно нужно?
==============================

В прошлый раз мы рассмотрели один из инструментов, используемых при промышленной разработке, — систему контроля версий
git. Так что на данный момент мы более или менее умеем делать две вещи: писать программы и хранить их. Но после того,
как программа написана, возникает вполне закономерный вопрос: работает ли она? И если работает, то работает ли она
именно так, как от неё этого ожидают?

Для ответа на эти, в общем-то простые на первый взгляд вопросы, программы подвергаются **тестированию**. По сути
тестирование — это процесс исследования работы программы с целью установить, соответствует ли она предъявляемым
требованиям.

Существует достаточное количество различных видов и методик тестирования: модульное, интеграционное, регрессионное и т.д.
Мы же рассмотрим только самый простой из них — **модульное тестирование** (**unit testing**).

Модульное тестирование
======================

Как следует из названия, основная задача модульного тестирования — проверить корректность функционирования отдельных
модулей. При этом под модулем понимается **не** модуль в терминах языка программирования, а некоторый законченный
фрагмент программы: обычно, это функция или класс.

Рассмотрим в качестве примера одну из задач, встречавшихся ранее: написать функцию, заменяющую в строке все вхождения
`'h'` кроме первого и последнего на на `'H'`. Одно из решений может выглядеть так:

.. code-block:: python

   def replace(s):
       return s.replace('h', 'H', s.count('h')-1).replace('H', 'h', 1)

И, казалось бы, это вполне правильное решение: сначала мы заменяем все `'h'` кроме последней на `'H'`, а затем заменяем
обратно первую `'H'` на `'h'`. Но на самом деле такое решение работает, но не во всех случаях:

.. code-block:: pycon

   >>> replace('aaa')
   'aaa'
   >>> replace('aaha')
   'aaha'
   >>> replace('aahha')
   'aahha'
   >>> replace('aahhha')
   'aahHha'
   >>> replace('Haahhha')
   'haaHHha'

Вот и ошибка: в последнем случае мы получили `'haaHHha'` вместо `'HaahHha'`. Это и есть несоответствие программы
предъявляемым к ней требованиям: на некоторых (вполне конкретных) входных данных она работает некорректно.

Выполненные нами проверки являются **ручным** тестирование: т.е. выполняются непосредственно человеком. Давайте
теперь напишем тесты, которые будут выполняться автоматически. В Питоне для этих целей есть специальный модуль —
**unittest**.

Модульные тесты, написанные при помощи  unittest, имеют такую структуру:

.. code-include:: code/lab6/unittest_example.py
    :lexer: python
    :encoding: utf-8

Все тесты по сути являются функциями (на самом деле методами класса, но это пока не важно), которые принадлежат
некоторому **набору** (**suite**). Набор тестов описывается **классом**. Мы не будем вдаваться подробности, касающиеся
классов и объектно-ориентированного программирования. Достаточно лишь обратить внимание на несколько моментов:

- тесты описываются при помощи функций внутри классов;
- имя каждой тестирующей функции начинается с `test_`;
- каждая тестирующая функция принимает один аргумент `self`.

Сами тесты состоят набора **утверждений** (**assertions**), посредством которых мы указываем, чего именно мы ожидаем.
Например, утверждение `self.assertEqual(a, b)` указывает на то, что мы ожидаем, что значения переменных `a` и `b` должны
быть равны. Если это не так, то в выполнение теста завершится с ошибкой. С полным списком существующих утверждений можно
ознакомиться `здесь`_.

.. _`здесь`: https://docs.python.org/3.4/library/unittest.html#assert-methods

Теперь напишем тест для нашей функции `replace`:

.. code-include:: code/lab6/replace_unittest.py
    :lexer: python
    :encoding: utf-8


Запустим тест (`python3 <имя_файла>`) и получим следующий вывод:

.. code-block:: plain

   test_1 (__main__.ReplaceTest) ... FAIL

   ======================================================================
   FAIL: test_1 (__main__.ReplaceTest)
   ----------------------------------------------------------------------
   Traceback (most recent call last):
     File "content/code/lab6/replace_unittest.py", line 12, in test_1
       self.assertEqual(replace('aahhha'), 'aahhha')
   AssertionError: 'aahHha' != 'aahhha'
   - aahHha
   ?    ^
   + aahhha
   ?    ^


   ----------------------------------------------------------------------
   Ran 1 test in 0.001s

   FAILED (failures=1)

Мы получили сообщение об ошибке в последней проверке: **ожидаемый** и **фактический** результат не совпали.

Мы рассмотрели пример создания простейшего модульного теста. Стоит отдельно сказать, что в данном случае мы написали
тест в том же файле, в котором реализована тестируемая функция. Обычно так не поступают: тексты программы хранятся в
одних файлах, тесты — в других.

Упражнение №1
-------------

Напишите модульные тесты к библиотеке `lib.py`_. Документация, описывающая библиотеку, приведена `тут`_.

.. _`lib.py`: {filename}/extra/lab6/lib.py
.. _`тут`: {filename}/extra/lab6/lib.m.html

В качестве примера приведём тесты для функции `sqrt`, которая согласно документации вычисляет квадратный корень из
числа. В случае отрицательного аргумента функция должна возвращать 0.

.. code-include:: code/lab6/lib_unittest_sqrt.py
    :lexer: python
    :encoding: utf-8

Результаты тестирования:

.. code-block:: plain
   :classprefix: pgcss

   test_sqrt_negative (__main__.LibTest) ... FAIL
   test_sqrt_non_negative_arg (__main__.LibTest) ... ok

   ======================================================================
   FAIL: test_sqrt_negative (__main__.LibTest)
   ----------------------------------------------------------------------
   Traceback (most recent call last):
     File "lib_unittest_sqrt.py", line 18, in test_sqrt_negative
       self.assertEqual(lib.sqrt(-1), 0)
   AssertionError: 1.0 != 0

   ----------------------------------------------------------------------
   Ran 2 tests in 0.000s

   FAILED (failures=1)

Как видим, функция `sqrt` для отрицательных значений возвращает ненулевое значение, что противоречит
документации.

Все функции библиотеки `lib.py` содержат ошибки (от одной до трёх). Напишите модульные тесты, выявляющие эти ошибки.

