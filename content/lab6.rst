Тестирование программ
#####################

:date: 2015-10-03 21:30
:test_link: http://judge2.vdi.mipt.ru/cgi-bin/new-client?contest_id=540106
:test_comment: Контрольная №6
:lecture_pdf: true
:lecture_link: https://youtu.be/wQvdbA2d5to

.. default-role:: code
.. contents:: Содержание


Тестирование: зачем оно нужно?
==============================

В прошлый раз мы рассмотрели один из инструментов, используемых при промышленной разработке, — систему контроля версий
git. Так что на данный момент мы более или менее умеем делать две вещи: писать программы и хранить их. Но после того,
как программа написана, возникает вполне закономерный вопрос: работает ли она? И если работает, то работает ли она
именно так, как от неё этого ожидают?

Для ответа на эти, в общем-то простые на первый взгляд вопросы, программы подвергаются **тестированию**. По сути
тестирование — это процесс исследования работы программы с целью установить, соответствует ли она предъявляемым
требованиям.

Существует достаточное количество различных видов и методик тестирования: модульное, интеграционное, регрессионное и т.д.
Мы же рассмотрим только самый простой из них — **модульное тестирование** (**unit testing**).

Модульное тестирование
======================

Как следует из названия, основная задача модульного тестирования — проверить корректность функционирования отдельных
модулей. При этом под модулем понимается **не** модуль в терминах языка программирования, а некоторый законченный
фрагмент программы: обычно, это функция или класс.

Рассмотрим в качестве примера одну из задач, встречавшихся ранее: написать функцию, заменяющую в строке все вхождения
`'h'` кроме первого и последнего на на `'H'`. Одно из решений может выглядеть так:

.. code-block:: python

   def replace(s):
       return s.replace('h', 'H', s.count('h')-1).replace('H', 'h', 1)

И, казалось бы, это вполне правильное решение: сначала мы заменяем все `'h'` кроме последней на `'H'`, а затем заменяем
обратно первую `'H'` на `'h'`. Но на самом деле такое решение работает, но не во всех случаях:

.. code-block:: pycon

   >>> replace('aaa')
   'aaa'
   >>> replace('aaha')
   'aaha'
   >>> replace('aahha')
   'aahha'
   >>> replace('aahhha')
   'aahHha'
   >>> replace('Haahhha')
   'haaHHha'

Вот и ошибка: в последнем случае мы получили `'haaHHha'` вместо `'HaahHha'`. Это и есть несоответствие программы
предъявляемым к ней требованиям: на некоторых (вполне конкретных) входных данных она работает некорректно.

Выполненные нами проверки являются **ручным** тестирование: т.е. выполняются непосредственно человеком. Давайте
теперь напишем тесты, которые будут выполняться автоматически. В Питоне для этих целей есть специальный модуль —
**unittest**.

Модульные тесты, написанные при помощи  unittest, имеют такую структуру:

.. code-include:: code/lab6/unittest_example.py
    :lexer: python
    :encoding: utf-8

Все тесты по сути являются функциями (на самом деле методами класса, но это пока не важно), которые принадлежат
некоторому **набору** (**suite**). Набор тестов описывается **классом**. Мы не будем вдаваться подробности, касающиеся
классов и объектно-ориентированного программирования. Достаточно лишь обратить внимание на несколько моментов:

- тесты описываются при помощи функций внутри классов;
- имя каждой тестирующей функции начинается с `test_`;
- каждая тестирующая функция принимает один аргумент `self`.

Сами тесты состоят набора **утверждений** (**assertions**), посредством которых мы указываем, чего именно мы ожидаем.
Например, утверждение `self.assertEqual(a, b)` указывает на то, что мы ожидаем, что значения переменных `a` и `b` должны
быть равны. Если это не так, то в выполнение теста завершится с ошибкой. С полным списком существующих утверждений можно
ознакомиться `здесь`_.

.. _`здесь`: https://docs.python.org/3.4/library/unittest.html#assert-methods

Теперь напишем тест для нашей функции `replace`:

.. code-include:: code/lab6/replace_unittest.py
    :lexer: python
    :encoding: utf-8


Запустим тест (`python3 <имя_файла>`) и получим следующий вывод:

.. code-block:: plain

   test_1 (__main__.ReplaceTest) ... FAIL

   ======================================================================
   FAIL: test_1 (__main__.ReplaceTest)
   ----------------------------------------------------------------------
   Traceback (most recent call last):
     File "content/code/lab6/replace_unittest.py", line 12, in test_1
       self.assertEqual(replace('aahhha'), 'aahhha')
   AssertionError: 'aahHha' != 'aahhha'
   - aahHha
   ?    ^
   + aahhha
   ?    ^


   ----------------------------------------------------------------------
   Ran 1 test in 0.001s

   FAILED (failures=1)

Мы получили сообщение об ошибке в последней проверке: **ожидаемый** и **фактический** результат не совпали.

Мы рассмотрели пример создания простейшего модульного теста. Стоит отдельно сказать, что в данном случае мы написали
тест в том же файле, в котором реализована тестируемая функция. Обычно так не поступают: тексты программы хранятся в
одних файлах, тесты — в других.

Упражнение №1
-------------

Напишите модульные тесты к библиотеке `lib.py`_. Документация, описывающая библиотеку, приведена `тут`_.

.. _`lib.py`: {filename}/extra/lab6/lib.py
.. _`тут`: {filename}/extra/lab6/lib.m.html

В качестве примера приведём тесты для функции `sqrt`, которая согласно документации вычисляет квадратный корень из
числа. В случае отрицательного аргумента функция должна возвращать 0.

.. code-include:: code/lab6/lib_unittest_sqrt.py
    :lexer: python
    :encoding: utf-8

Результаты тестирования:

.. code-block:: plain
   :classprefix: pgcss

   test_sqrt_negative (__main__.LibTest) ... FAIL
   test_sqrt_non_negative_arg (__main__.LibTest) ... ok

   ======================================================================
   FAIL: test_sqrt_negative (__main__.LibTest)
   ----------------------------------------------------------------------
   Traceback (most recent call last):
     File "lib_unittest_sqrt.py", line 18, in test_sqrt_negative
       self.assertEqual(lib.sqrt(-1), 0)
   AssertionError: 1.0 != 0

   ----------------------------------------------------------------------
   Ran 2 tests in 0.000s

   FAILED (failures=1)

Как видим, функция `sqrt` для отрицательных значений возвращает ненулевое значение, что противоречит
документации.

Все функции библиотеки `lib.py` содержат ошибки (от одной до трёх). Напишите модульные тесты, выявляющие эти ошибки.

Непрерывная интеграция
======================

Как мы убедились, тестирование сильно облегчает процесс разработки программного обеспечения: при правильно выстроенном
подходе к составлению тестов большинство ошибок можно обнаружить до начала процесса эксплуатации. При этом, как правило,
над бльшими проектами трудится не один десяток человек. Это означает, что изменения, вносимые участниками по отдельности
могут и не вызывать ошибок в программе, а вот сочетание этих изменений — наоборот, приводить к возникновению ошибок в
программе. Это вполне закономерный результат: когда один программист вносит изменения в программу он редко задумывается
о том, решением каких проблем озадачен его коллега. В конечном счёте это часто приводит к тому, что новые ошибки
возникают в процессе исправления старых. При этом локальное тестирование говорит, что всё хорошо: без чужих изменений
все тесты проходят без ошибок.

В таком случае было бы правильнее запускать выполнение тестов в автоматическом режиме после того, как изменения
опубликованы в репозитории (например, при помощи команды `git push`). При этом подходе тестированию будет подвергаться
самая актуальная версия разрабатываемого программного обеспечения, содержащая правки, сделанные несколькими
разработчиками.

Для автоматического запуска процедур тестирования при промышленной разработке используются **системы непрерывной
интеграции** (**continious integration**, **CI**). На самом деле, эти системы решают гораздо больший круг задач, нежели
запуск тестов в автоматическом режиме, но это рассмотреение этих вопросов выходит далеко за рамки курса.

В этой работе мы будет использовать систему непрерывной интеграции `TravisCI`, поскольку она имеет встроенные механизмы
интеграции с GitHub. Ваша задача проста и обыденна — решить задачи. Но особенность этой работы заключается в том, что
все свои решения вы публикуете на GitHub (помните про `git push`?), а `TravisCI` автоматически запускает заранее
подготовленные скрипты для проверки работоспособности ваших программ. Итак, для начала нам требуется настроить
репозиторий для хранения решений и интеграцию с TravisCI. Для этого нужно сделать несколько простых шагов:

1. Войдите на сайт `GitHub`_ при помощи своих логина и пароля.
2. Откройте `страницу`_ с подготовленным репозиторием и нажмите кнопку `Fork` в правом верхнем углу.

.. image:: {filename}/images/lab6/fork.png
   :width: 100%

3. Убедитесь, что была создана копия репозитория.

.. image:: {filename}/images/lab6/forked.png
   :width: 100%

4. Отредактируйте файл README.md, вписав в него вместо строки ИМЯ_ПОЛЬЗОВАТЕЛЯ свой логин от GitHub.

.. image:: {filename}/images/lab6/readme.png
   :width: 100%

.. image:: {filename}/images/lab6/readme_edit.png
   :width: 100%

.. image:: {filename}/images/lab6/readme_edit_username.png
   :width: 100%

.. image:: {filename}/images/lab6/readme_edit_commit.png
   :width: 100%

5. Перейдите на сайт `TravisCI`_ и нажмите кнопку `Sign Up`.

.. image:: {filename}/images/lab6/travis_sign_up.png
   :width: 100%

6. Разрешите доступ `TravisCI` к вашим репозиториям, нажав кнопку `Authorize app`.

.. image:: {filename}/images/lab6/github_authorize_travis.png

7. Перейдите на страницу добавления репозитория, кликнув на `+`.

.. image:: {filename}/images/lab6/travis_add_repo.png

8. Нажмите на кнопку `Sync` для обновления списка репозиториев.

.. image:: {filename}/images/lab6/travis_sync.png

9. Включите TravisCI для своего репозитория `lab6`.

.. image:: {filename}/images/lab6/travis_enable_repo.png

10. Откройте главную страницу `TravisCI`_ и выберите в списке слева свой репозиторий `lab6`. Если он отсутствует,
нажмите `F5` для обновления страницы.

.. image:: {filename}/images/lab6/travis_select_repo.png

11. Настройка завершена. Теперь после того, как вы будете выполнять `git push` в своём репозитории, `TravisCI` будет
автоматически запускать скрипты тестирования. Обратите внимание, что на странице с вашим репозиторием на `GitHub`
появился значок, отображающий статус выполнения тестов. В зависимости от результата выполнения тестов он будет иметь
различный цвет.

.. image:: {filename}/images/lab6/github_travis_badge.png
   :width: 100%

12. По нажатию на него вы попадёте на страницу с результатами тестирования ваших задач.

.. image:: {filename}/images/lab6/check_status.png
   :width: 100%

.. _`GitHub`: https://github.com
.. _`страницу`: https://github.com/mipt-cs-on-python3/lab6
.. _`TravisCI`: https://travis-ci.org/

Упражнение №2
-------------

Решите задачи, предложенные ниже. Вы должны загрузить свои решения в репозиторий `lab6` на `GitHub`, который только что
создали. Файлы должны соответствовать названиям задач: `A.py`, `B.py` и т.д.

Во всех задачах ввод входных данных осуществляется из файла `input.txt`, а вывод — в файл `output.txt`. Так как задачи
проверяются в автоматическом режиме, любой вывод лишних строк (например, "Введите N") будет считаться неверным. Вводите
и выводите только те данные, что указаны в условии задачи.

Задача A
++++++++

В массиве ровно два элемента равны. Найдите эти элементы.

Программа получает на вход число N, в следующей строке заданы N элементов списка через пробел.

Выведите значение совпадающих элементов.

+-------------+-------+
| Ввод        | Вывод |
+=============+=======+
| 6           | 5     |
+-------------+-------+
| 8 3 5 4 5 1 |       |
+-------------+-------+

Задача B
++++++++

Одна фирма обслуживает автоматы по продаже чая и кофе.

Стоимость стакана чая и кофе в автомате равна пяти рублям. Автомат принимает монеты по 5 и 10 рублей, а также купюры в
10, 50 и 100 рублей. Когда покупателю надо выдавать сдачу (т.е. когда пассажир бросил в автомат десятирублёвую монету
или 10-, 50- или 100-рублёвую купюру), автомат выдаёт сдачу пятирублёвыми монетами; если же покупатель бросил в автомат
пятирублёвую монету, то автомат её сохраняет и может использовать для сдачи следующим покупателям.

Ясно, что, чтобы обеспечить возможность выдачи сдачи всем покупателям, может потребоваться изначально загрузить в
автомат некоторое количество пятирублёвых монет. Сейчас автоматы проходят испытания с целью определить минимальное
количество монет, которые надо загрузить в автомат перед началом дня. Вам дан протокол одного из таких испытаний:
известен порядок, в котором покупатели оплачивали свои покупки различными монетами и купюрами. Определите, какое
минимальное количество пятирублёвых монет должно было изначально находиться в автомате, чтобы всем покупателям хватило
сдачи.

В первой строке входных данных находится одно натуральное число N — количество покупок в автомате, которые были
совершены в ходе испытания (1≤N≤50000). Во второй строке находятся N натуральных чисел, каждое из которых равно номиналу
монеты или купюры, которую использовал очередной покупатель для оплаты; каждый номинал может принимать одно из четырёх
значений: 5, 10, 50 или 100.

Выведите одно число — минимальное количество пятирублёвых монет, которые надо было загрузить в автомат изначально, чтобы
всем покупателям хватило сдачи.

+----------+-------+
| Ввод     | Вывод |
+==========+=======+
| 3        | 19    |
+----------+-------+
| 10 5 100 |       |
+----------+-------+
+----------+-------+
| 3        | 0     |
+----------+-------+
| 5 5 10   |       |
+----------+-------+
+----------+-------+
| 4        | 9     |
+----------+-------+
| 50 5 5 5 |       |
+----------+-------+


Задача C
++++++++

В прихожей в ряд стоит N тапочек, которые бывают разных размеров, а также левыми и правыми. Гость выбирает два тапочка,
удовлетворяющих следующим условиям:

- выбранные тапочки должны быть одного размера;
- из выбранных тапочков левый тапочек должен стоять левее правого;
- если можно выбрать несколько пар тапочек, удовлетворяющих первым двум условиям, то выбирается два тапочка с наименьшим
  расстоянием между ними.

В первой строке входны данных записано число тапочков N. Во второй строке записаны размеры тапочков в порядке слева
направо, при этом левые тапочки условно обозначаются отрицательными числами (то есть -s обозначает левый тапочек, а s
обозначает правый тапочек размера s).

Выведите одно число: минимальное расстояние между двумя тапочками одного размера таких, что левый тапочек стоит левее
правого. Если таких пар тапочек нет, то выведите одно число 0.

+----------------------+-------+
| Ввод                 | Вывод |
+======================+=======+
| 6                    | 2     |
+----------------------+-------+
| -40 41 -42 -41 42 40 |       |
+----------------------+-------+


Задача D
++++++++

Метеорологи ведут многолетние наблюдения за тем, в каком году была минимальная температура в данный день года. Например,
абсолютный минимум температуры в Москве 8 марта был -32 градуса (1890).

В течение k лет метеорологи вели наблюдения за n днями года. Для каждого из этих n дней укажите минимальную температуру,
которая была в этот день за k лет наблюдений.

Первая строка входных данных содержит два числа k и n. Далее идет k строк, i-я строка содержит n чисел: значения
температур для n дней наблюдений i-го года.

Программа должна вывести n чисел: миниальное значение температуры для каждого из дней наблюдений.

+---------+-----------+
| Ввод    | Вывод     |
+=========+===========+
| 3       | 4 3 2 4 3 |
+---------+-----------+
| 8 6 4 7 |           |
+---------+-----------+
| 3 2 5 4 |           |
+---------+-----------+
| 6 4 6 3 |           |
+---------+-----------+


Задача E
++++++++

В одном карточном клубе состоит N джентльменов. Иногда азарт некоторых из них берет верх над благоразумием, и кто-то
проигрывает больше денег, чем у него есть с собой. В этом случае проигравший обычно берет в долг у кого-то из
посетителей клуба, чтобы расплатиться с партнерами по игре. Чтобы начать новый год “с чистого листа”, джентльмены решили
собраться в клубе и оплатить все долговые расписки, которые накопились у них друг к другу. Однако выяснилось, что иногда
одни и те же джентльмены в разные дни выступали как в роли должников, так и в роли кредиторов. Поскольку истинные
джентльмены считают мелочный подсчет денег ниже своего достоинства, то расчетами придется заняться вам.

Напишите программу, которая по заданным распискам вычислит, сколько всего должен каждый джентльмен выплатить другим (или
получить с других).

Первая строка входных данных содержит сначала число N — количество джентльменов (натуральное, не превышает 100, не менее
2), и число K — количество долговых расписок (натуральное, не превышает 10000), после этого следует K троек чисел: номер
джентльмена взявшего в долг, номер джентльмена давшего деньги и сумма. Номера джентльменов в расписках — натуральные
числа, не превышающие N. Сумма — натуральное число, не превышает 100. Гарантируется, что ни один джентльмен не брал в
долг сам у себя.

Выведите N чисел — суммы, которые должны получить соответствующие джентльмены. Выведите положительное число, если этот
джентльмен должен получить деньги от других, отрицательное — если он должен отдать деньги другим.

+---------+------------+
| Ввод    | Вывод      |
+=========+============+
| 2 3     | -50 50     |
+---------+------------+
| 1 2 10  |            |
+---------+------------+
| 1 2 20  |            |
+---------+------------+
| 1 2 20  |            |
+---------+------------+
+---------+------------+
| 3 1     | 100 0 -100 |
+---------+------------+
| 3 1 100 |            |
+---------+------------+
