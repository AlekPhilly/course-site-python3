Введение в Python 3
#########################################

:date: 2015-09-10 14:23
:test_comment: Регистрация на контрольную №2
:test_link: http://kpm8.mipt.ru:8202/cgi-bin/new-register?contest_id=540102

.. default-role:: code
.. contents:: Содержание



Введение
========

Данный курс будет посвящен изучению программирования с использованием языка **Python**. Это — современный язык
программирования, работающий на всех распространных операционных системах.

В настоящее время существует две версии языка Python: более старая, но пока ещё более распространненая версия 2 и
современная версия 3. Они не вполне совместимы друг с другом: программа, написанная для одной версии языка может
оказаться невыполнимой для другой версии. Но в основном обе версии очень похожи.

Мы будем использовать версию 3 данного языка, некоторые из используемых примеров не будут работать с версией 2.
Последняя версия языка, доступная в сентябре 2015 года — 3.4.3, именно её необходимо установить дома, скачав данную
версию с сайта www.python.org_.

.. _www.python.org: http://www.python.org

Запустить интерпретатор python можно из командной строки:

.. code-block:: bash

   python3

Будьте внимательны — команда `python` запустит интерпретатор версии 2, с которым мы работать не будем. В системе
Windows можно использовать пункт меню «Python (command line)».

IPython — расширенная оболочка
==============================


IPython — интерактивная оболочка для языка программирования Python, которая предоставляет расширенную интроспекцию,
дополнительный командный синтаксис, подсветку кода и автоматическое дополнение. Является компонентом пакета программ
SciPy.

IPython может использоваться как замена стандартной командной оболочки операционной системы, особенно на платформе
Windows, возможности оболочки которой ограничены. Поведение по умолчанию похоже на поведение оболочек UNIX-подобных
систем, но тот факт, что работа происходит в окружении Python, позволяет добиваться большей настраиваемости и
гибкости.

Для обучения возможностям Python лучше сразу использовать оболочку IPython_.

.. _IPython: http://ipython.org/


Итак, запустив оболочку Python Вы увидите примерно следующее приглашение командной строки:

.. code-block:: pycon

   Python 3.1.2 (r312:79147, Jun 12 2010, 15:29:06)
   [GCC 4.4.3 20100316 (ALT Linux 4.4.3-alt2)] on linux2
   Type "help", "copyright", "credits" or "license" for more information.
   >>>

Смело вводите команды и наслаждайтесь результатом. А что можно вводить? Несколько примеров:

.. code-block:: pycon

   >>> 2 + 2
   4
   >>> 2 ** 100
   1267650600228229401496703205376
   >>> 'Hello' + 'World'
   'HelloWorld'
   >>> 'ABC' * 10
   'ABCABCABCABCABCABCABCABCABCABC'

Первая команда вычисляет сумму двух чисел, вторая команда вычисляет 2 в степени 100, третья команда выполняет операцию
**конкатенации** для строк, а четвертая команда печатает строку `'ABC'`, повторенную 100 раз.

Хотите закончить работу с питоном? Введите команду `exit()` (именно так, со скобочками, так как это — **функция**)
или нажмите ``Ctrl+D``.

Типы данных
===========

Итак, мы видим, что Python умеет работать как минимум с двумя видами данных — числами и строками. Числа записываются
последовательностью цифр, также перед числом может стоять знак минус, а строки записываются в одинарных кавычках. `2`
и `'2'` — это разные объекты, первый объект — число, а второй — строка. Операция ``+`` для целых чисел и для строк
работает по-разному: для чисел это сложение, а для строк — конкатенация.

Кроме целых чисел есть и другой класс чисел: действительные (вещественные числа), представляемые в виде десятичных
дробей. Они записываются с использованием десятичной точки, например, `2.0`. В каком-то смысле, `2` и `2.0`
имеют равные значение, но это — разные объекты. Например, можно вычислить значения выражения `'ABC'*10` (повторить
строку 10 раз), но нельзя вычислить `'ABC'*10.0`.

Определить тип объекта можно при помощи функции `type`:

.. code-block:: pycon

   >>> type(2)
   <class 'int'>
   >>> type('2')
   <class 'str'>
   >>> type(2.0)
   <class 'float'>

Обратите внимание — `type` является функцией, аргументы функции указываются в скобках после ее имени.

Вот список основных операций для чисел:

- `A+B` — сумма;
- `A-B` — разность;
- `A*B` — произведение;
- `A/B` — частное;
- `A**B` — возведение в степень.

Полезно помнить, что квадратный корень из числа ``x`` — это `x**0.5`, а корень степени ``n`` — это `x**(1/n)`.

Есть также унарный вариант операции ``-``, то есть операция с одним аргументом. Она возвращает число, противоположное
данному. Например: `-A`.

В выражении может встречаться много операций подряд. Как в этом случае определяется порядок действий? Например, чему
будет равно `1+2*3**1+1`? В данном случае ответ будет 8, так как сначала выполняется возведение в степень, затем —
умножение, затем —  сложение.

Более общие правила определения приоритетов операций такие:

#. Выполняются возведения в степень  **справа налево**, то есть `3**3**3` это 3²⁷.
#. Выполняются унарные минусы (отрицания).
#. Выполняются умножения и деления слева направо. Операции умножения и деления имеют одинаковый приоритет.
#. Выполняются сложения и вычитания слева направо. Операции сложения и вычитания имеют одинаковый приоритет.

Основные операции над строками:

- `A+B` — конкатенация;
- `A*n` — повторение ``n`` раз, значение ``n`` должно быть целого типа.


Упражнение №1: возведение в степень
-----------------------------------

Вычислите 2¹⁷⁹.

Упражнение №2: гипотенуза
-------------------------

Вычислите длину гипотенузы в прямоугольном треугольнике со сторонами 179 и 971.

Преобразование типов
====================

Иногда бывает полезно целое число записать, как строку. И, наоборот, если строка состоит из цифр, то полезно эту строку
представить в виде числа, чтобы дальше можно было выполнять арифметические операции с ней. Для этого используются
функции, одноименные с именем типа, то есть `int`, `float`,  `str`. Например, `int('123')` вернет целое число `123`, а
`str(123)` вернет строку `'123'`.

Пример:

.. code-block:: pycon

   >>> str(2 + 2) * int('2' + '2')
   '4444444444444444444444'

Результатом будет строка из числа ``4``, повторенная ``22`` раза.

Пишем простейшие программы
==========================

В предыдущем задании мы использовали Python для простых разовых вычислений, используя интерактивный режим. Например,
было задание вычислить длину гипотенузы прямоугольного треугольника по ее катетам. Запустите текстовый редактор и
напишите следующий текст:

.. code-block:: python

   a = 179
   b = 197
   c = (a ** 2 + b ** 2) ** 0.5
   print (c)

Здесь мы используем  **переменные** — объекты, в которых можно сохранять различные (числовые, строковые и прочие)
значения. В первой строке переменной `a` присваивается значение `179`, затем переменной `b` присваивается значение
`971`, затем переменной `c` присваивается значение арифметического выражения, равному длине гипотенузы. После этого
значение переменной `c` выводится на экран.

Сохраните этот текст в файле с именем `hypot.py`. Запустите терминал, перейдите в каталог, где лежит этот файл и
выполните эту программу:

.. code-block:: bash

   python3 hypot.py

Интерпретатор языка Python, запущенный с указанием имени файла, запускается не в интерактивном режиме, а выполняет ту
последовательность команд, которая сохранена в файле. При этом значения вычисленных выражений не выводятся на экран (в
отличии от интерактивного режима), поэтому для того, чтобы вывести результат работы программы, то есть значение
переменной `c`, нам понадобится специальная функция `print`.

Ввод данных: функция `input()`
==============================

Пример выше неудобен тем, что исходные данные для программы заданы в тексте программы, и для того, чтобы использовать
программу для другого треугольника необходимо исправлять текст программы. Это неудобно, лучше, чтобы текст программы не
менялся, а программа запрашивала бы у пользователя данные, необходимые для решения задачи, то есть запрашивала бы
значения двух исходных переменных `a` и `b`. Для этого будем использовать функцию `input()`, которая считывает строку с
клавиатуры и возвращает значение считанной строки, которое сразу же присвоим переменым `a` и `b`:

.. code-block:: python

   a = input()
   b = input()

Правда, функция `input` возвращает текстовую строку, а нам нужно сделать так, чтобы переменные имели целочисленные
значения. Поэтому сразу же после считывания выполним преобразование типов при помощи фунцкии `int`, и запишем новые
значения в переменные `a` и `b`.

.. code-block:: python

   a = int(a)
   b = int(b)


Можно объединить считывание строк и преобразование типов, если вызывать функцию `int` для того значения, которое вернет
функция `input`:

.. code-block:: python

   a = int(input())
   b = int(input())

Далее в программе вычислим значение переменной `c` и выведем результат на экран.

Теперь мы можем не меняя исходного кода программы многократно использовать ее для решения различных задач. Для того
нужно запустить программу и после запуска программы ввести с клавиатуры два числа, нажимая после кажого числа клавишу
`Enter`. Затем программа сама выведет результат.

Вывод данных: функция `print()`
===============================

Функция `print` может выводить не только значения переменных, но и значения любых выражений. Например, допустима запись
`print(2 + 2 ** 2)`. Также при помощи функции `print` можно выводить значение не одного, а нескольких выражений, для
этого нужно перечислить их через запятую:

.. code-block:: python

   a = 1
   b = 2
   print(a, '+', b, '=', a + b)

В данном случае будет напечатан текст `1 + 2 = 3`: сначала выводится зание переменной `a`, затем строка из знака `+`,
затем  значение переменной `b`, затем строка из знака `=`, наконец, значение суммы `a + b`.

Обратите внимание, выводимые значение разделяются одним пробелом. Но такое поведение можно изменить: можно разделять
выводимые значения двумя пробелами, любым другим символом, любой другой строкой, выводить их в отдельных строках или не
разделять никак. Для этого нужно функции `print` передать специальный именованный параметр, называемый `sep`, равный
строке, используемый в качестве разделителя (sep —  аббревиатура от слова separator, т.е. разделитель). По умолчанию
параметр `sep` равен строке из одного пробела и между значениями выводится пробел. Чтобы использовать в качестве
разделителя, например, символ двоеточия нужно передать параметр `sep`, равный строке `':'`:

.. code-block:: python

   print(a, b, c, sep = ':')

Аналогично, для того, чтобы совсем убрать разделитель при выводе нужно передать параметр `sep`, равный пустой строке:

.. code-block:: python

   print(a, '+', b, '=', a + b, sep = '')

Для того, чтобы значения выводились с новой строке, нужно в качестве параметра `sep` передать строку, состоящую из
специального символа новой строки, которая задается так:

.. code-block:: python

   print(a, b, sep = '\n')

Символ обратного слэша в текстовых строках является указанием на обозначение специального символа, в зависимости
от того, какой символ записан после него. Наиболее часто употребляется символ новой строки `'\n'`.
А для того, чтобы вставить в строку сам символ обратного слэша, нужно повторить его два раза: `'\\'`.

Вторым полезным именованным параметром функции `print` является параметр `end`,
который указывает на то, что выводится после вывода всех значений, перечисленных в функции `print`.
По умолчанию параметр `end` равен `'\n'`, то есть следующий вывод будет происходить
с новой строки. Этот параметр также можно исправить, например, для того, чтобы убрать все дополнительные
выводимые символы можно вызывать функцию `print` так:

.. code-block:: python

   print(a, b, c, sep = '', end = '')

Упражнение №3: гипотенуза с пользовательским вводом
---------------------------------------------------

Дано два числа `a` и `b`. Выведите гипотенузу треугольника с заданными катетами.

+------+-------+
| Ввод | Вывод |
+======+=======+
| 3    | 5     |
+------+-------+
| 4    |       |
+------+-------+

Упражнение №4: следующее и предыдущее
-------------------------------------

Напишите программу, которая считывает целое число и выводит текст, аналогичный приведенному
в примере:

+------+-------------------------------------------------+
| Ввод | Вывод                                           |
+======+=================================================+
| 2015 | The next number for the number 2015 is 2016     |
+------+-------------------------------------------------+
|      | The previous number for the number 2015 is 2014 |
+------+-------------------------------------------------+

Целочисленная арифметика
========================

Для целых чисел определены ранее рассматривавшиеся операции `+`, `-`, `*` и `**`. Операция деления `/` для целых чисел
возвращает значение типа `float`. Также функция возведения в степень возвращает значение типа `float`, если показатель
степени — отрицательное число.

Но есть и специальная операция целочисленного деления, выполняющегося с отбрасыванием дробной части, которая
обозначается `//`. Она возвращает целое число: целую часть частного. Например:

.. code-block:: pycon

   >>> 17 // 3
   5
   >>> -17 // 3
   -6

Другая близкая ей операция — это операция взятия остатка от деления, обозначаемая `%`:

.. code-block:: pycon

   >>> 17 % 3
   2
   >>> -17 % 3
   1

Упражнение №5: последняя цифра
------------------------------

Дано натуральное число. Выведите его последнюю цифру. Пример:

+------+-------+
| Ввод | Вывод |
+======+=======+
| 179  | 9     |
+------+-------+

Упражнение №6: число десятков
-----------------------------

Дано натуральное число. Найдите число десятков в его десятичной записи (то есть вторую справа цифру его десятичной
записи). Пример:

+------+-------+
| Ввод | Вывод |
+======+=======+
| 179  | 7     |
+------+-------+

Символы. Коды символов
======================

Любой текст состоит из символов. Символ — это некоторый значок, изображение. Один и тот же символ можно записать по-
разному, например, два человека по-разному напишут от руки букву «A», и даже в компьютерном представлении одна и та же
буква будет выглядеть по-разному, если ее отображать разными шрифтами, при этом это будет все равно один и тот же
символ. Верно и другое: разные символы могут быть записаны одинаково, например, вот две разные буквы, одна — латинского
алфавита, другая - русского: «A» и «А». Несмотря на то, что они выглядят одинаково, удобней считать их разными
символами.

Итак, способ хранения текстовой информации в компьютере не связан напрямую с изображением этого текста. Вместо символов
хранятся их номера - числовые коды, а вот то, как выглядит символ с данным числовым кодом на экране напрямую зависит от
того, какой используется шрифт для отображения символов. При этом, разумеется, следовало бы договориться о единообразном
способе кодирования символов числовыми кодами, иначе текст, записанный на одном компьютере, невозможно будет прочитать
на другом компьютере.

Первоначально договорились под кодирование одного символа отвести один байт, то есть 8 бит информации. Таким образом
можно было закодировать 256 различных значений, то есть в записи текста можно использовать 256 различных символов. Этого
достаточно, чтобы отобразить все символы латинского алфавита, цифры, знаки препинания и некоторые другие символы.
Стандарт, указывающий, какие числовые коды соответствуют каким основным символам, называется  ASCII_. В таблицу ASCII
включены символы с кодами от 0 до 127, то есть ASCII - это семибитный код. Вот так выглядит таблица ASCII:

.. _ASCII: http://ru.wikipedia.org/wiki/ASCII

+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| Char  | Dec | Oct  | Hex  | Char | Dec | Oct  | Hex  | Char | Dec | Oct  | Hex  | Char  | Dec | Oct  | Hex  |
+=======+=====+======+======+======+=====+======+======+======+=====+======+======+=======+=====+======+======+
| (nul) | 0   | 0000 | 0x00 | (sp) | 32  | 0040 | 0x20 | @    | 64  | 0100 | 0x40 | \`    | 96  | 0140 | 0x60 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (soh) | 1   | 0001 | 0x01 | !    | 33  | 0041 | 0x21 | A    | 65  | 0101 | 0x41 | a     | 97  | 0141 | 0x61 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (stx) | 2   | 0002 | 0x02 | "    | 34  | 0042 | 0x22 | B    | 66  | 0102 | 0x42 | b     | 98  | 0142 | 0x62 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (etx) | 3   | 0003 | 0x03 | #    | 35  | 0043 | 0x23 | C    | 67  | 0103 | 0x43 | c     | 99  | 0143 | 0x63 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (eot) | 4   | 0004 | 0x04 | $    | 36  | 0044 | 0x24 | D    | 68  | 0104 | 0x44 | d     | 100 | 0144 | 0x64 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (enq) | 5   | 0005 | 0x05 | %    | 37  | 0045 | 0x25 | E    | 69  | 0105 | 0x45 | e     | 101 | 0145 | 0x65 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (ack) | 6   | 0006 | 0x06 | &    | 38  | 0046 | 0x26 | F    | 70  | 0106 | 0x46 | f     | 102 | 0146 | 0x66 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (bel) | 7   | 0007 | 0x07 | '    | 39  | 0047 | 0x27 | G    | 71  | 0107 | 0x47 | g     | 103 | 0147 | 0x67 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (bs)  | 8   | 0010 | 0x08 | (    | 40  | 0050 | 0x28 | H    | 72  | 0110 | 0x48 | h     | 104 | 0150 | 0x68 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (ht)  | 9   | 0011 | 0x09 | )    | 41  | 0051 | 0x29 | I    | 73  | 0111 | 0x49 | i     | 105 | 0151 | 0x69 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (nl)  | 10  | 0012 | 0x0a | \*   | 42  | 0052 | 0x2a | J    | 74  | 0112 | 0x4a | j     | 106 | 0152 | 0x6a |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (vt)  | 11  | 0013 | 0x0b | \+   | 43  | 0053 | 0x2b | K    | 75  | 0113 | 0x4b | k     | 107 | 0153 | 0x6b |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (np)  | 12  | 0014 | 0x0c | ,    | 44  | 0054 | 0x2c | L    | 76  | 0114 | 0x4c | l     | 108 | 0154 | 0x6c |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (cr)  | 13  | 0015 | 0x0d | \-   | 45  | 0055 | 0x2d | M    | 77  | 0115 | 0x4d | m     | 109 | 0155 | 0x6d |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (so)  | 14  | 0016 | 0x0e | .    | 46  | 0056 | 0x2e | N    | 78  | 0116 | 0x4e | n     | 110 | 0156 | 0x6e |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (si)  | 15  | 0017 | 0x0f | /    | 47  | 0057 | 0x2f | O    | 79  | 0117 | 0x4f | o     | 111 | 0157 | 0x6f |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (dle) | 16  | 0020 | 0x10 | 0    | 48  | 0060 | 0x30 | P    | 80  | 0120 | 0x50 | p     | 112 | 0160 | 0x70 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (dc1) | 17  | 0021 | 0x11 | 1    | 49  | 0061 | 0x31 | Q    | 81  | 0121 | 0x51 | q     | 113 | 0161 | 0x71 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (dc2) | 18  | 0022 | 0x12 | 2    | 50  | 0062 | 0x32 | R    | 82  | 0122 | 0x52 | r     | 114 | 0162 | 0x72 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (dc3) | 19  | 0023 | 0x13 | 3    | 51  | 0063 | 0x33 | S    | 83  | 0123 | 0x53 | s     | 115 | 0163 | 0x73 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (dc4) | 20  | 0024 | 0x14 | 4    | 52  | 0064 | 0x34 | T    | 84  | 0124 | 0x54 | t     | 116 | 0164 | 0x74 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (nak) | 21  | 0025 | 0x15 | 5    | 53  | 0065 | 0x35 | U    | 85  | 0125 | 0x55 | u     | 117 | 0165 | 0x75 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (syn) | 22  | 0026 | 0x16 | 6    | 54  | 0066 | 0x36 | V    | 86  | 0126 | 0x56 | v     | 118 | 0166 | 0x76 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (etb) | 23  | 0027 | 0x17 | 7    | 55  | 0067 | 0x37 | W    | 87  | 0127 | 0x57 | w     | 119 | 0167 | 0x77 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (can) | 24  | 0030 | 0x18 | 8    | 56  | 0070 | 0x38 | X    | 88  | 0130 | 0x58 | x     | 120 | 0170 | 0x78 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (em)  | 25  | 0031 | 0x19 | 9    | 57  | 0071 | 0x39 | Y    | 89  | 0131 | 0x59 | y     | 121 | 0171 | 0x79 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (sub) | 26  | 0032 | 0x1a | :    | 58  | 0072 | 0x3a | Z    | 90  | 0132 | 0x5a | z     | 122 | 0172 | 0x7a |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (esc) | 27  | 0033 | 0x1b | ;    | 59  | 0073 | 0x3b | [    | 91  | 0133 | 0x5b | {     | 123 | 0173 | 0x7b |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (fs)  | 28  | 0034 | 0x1c | <    | 60  | 0074 | 0x3c | \\   | 92  | 0134 | 0x5c | \|    | 124 | 0174 | 0x7c |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (gs)  | 29  | 0035 | 0x1d | =    | 61  | 0075 | 0x3d | ]    | 93  | 0135 | 0x5d | }     | 125 | 0175 | 0x7d |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (rs)  | 30  | 0036 | 0x1e | >    | 62  | 0076 | 0x3e | ^    | 94  | 0136 | 0x5e | ~     | 126 | 0176 | 0x7e |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (us)  | 31  | 0037 | 0x1f | ?    | 63  | 0077 | 0x3f | _    | 95  | 0137 | 0x5f | (del) | 127 | 0177 | 0x7f |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+


При этом символы с кодами, меньшими 32 — это специальные управляющие символы, которые не отображаются на экране.
Например, для того, чтобы обозначить конец строки в системе Linux используется один символ с кодом 10, а в системе
Windows — два подряд идущих символа с кодами 13 и 10, символы с кодами 48-57 соответствуют начертанию арабских цифр
(обратите внимание, символ с кодом 0 - это вовсе не символ, отображающийся на экране, как «0»), символы с кодами 65-90 —
заглавные буквы буквы латинского алфавита, а если к их кодам прибавить 32, то получатся строчные буквы латинского
алфавита. В промежутках между указанными диапазонами находятся знаки препинания, математические операции и прочие
символы.

Но в ASCII-таблицы нет русских букв! А также нет букв сотен других национальных алфавитов. Первоначально для отображения
букв национальных алфавитов использовали вторую половину возможного значения байта, то есть символы с кодами от 128 до
255. Это приводило к множеству проблем, например, поскольку 128 значений явно недостаточно для того, чтобы отобразить
символы всех национальных алфавитов (даже недостаточно для того, чтобы отобразить символы одного алфавита, например,
`китайской письменности`_. Поэтому в настоящее время для кодирования символов используется стандарт Unicode_ версия 6.0
которого (октябрь, 2010) включает свыше 109000 различных символов. Естественно, для кодирования Unicode-символов
недостаточно одного байта на символ, поэтому используются многобайтовые кодировки (для представления одного символа
необходимо несколько байт).

.. _`китайской письменности`: http://ru.wikipedia.org/wiki/%D0%9A%D0%B8%D1%82%D0%B0%D0%B9%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D0%B8%D1%81%D1%8C%D0%BC%D0%BE
.. _Unicode: http://ru.wikipedia.org/wiki/Unicode

Язык программирования Python — современный язык, поэтому он работает исключительно с Unicode-символами.

Код символа можно определить при помощи функции `ord`. Эта функция получает на вход строку, которая дол на состоять
ровно из одного символа. Функция возвращает код этого символа. Например, `ord('A')` вернет число `65`.

Обратная функция получения по числовому коду его номера называется `chr`.

Сравнение символов
==================

Поскольку для символов заданы их числовые коды, то их можно сравнивать при помощи операций сравения. Поскольку символы
алфавита идут подряд, то результат их сравнения будет соответствовать лексикографическому порядку, но можно сравнивать
между собой не только буквы алфавита, но и два произвольных символа.

Также в питоне определены и операции сравнения строк, которые также сравниваются в лексикографическом порядке.

Упражнение №7: код ASCII-символа
--------------------------------

Считайте со стандартного ввода символ и выведите его код.

Программа получает на вход один символ с кодом от 33 до 126. Пример:

+------+-------+
| Ввод | Вывод |
+======+=======+
| A    | 65    |
+------+-------+


Упражнение №8: символ с данным ASCII-кодом
------------------------------------------

Считайте со стандартного ввода целое число и выведите ASCII-символ с таким кодом. Решите эту задачу с использованием
только одной переменной типа `int`.

Программа получает на вход число от 33 до 126. Пример:

+------+-------+
| Ввод | Вывод |
+======+=======+
| A    | 65    |
+------+-------+

Строки
======

Строка считывается со стандартного ввода функцией `input()`. Напомним, что для двух строк определа операция сложения
(конкатенации), также определена операция умножения строки на число.

Строка состоит из последовательности символов. Узнать количество символов (длину строки) можно при помощи функции `len`:


.. code-block:: pycon

   >>> S = 'Hello'
   >>> print(len(S))
   5

Срезы (slices)
==============

Срез (slice) — извлечение из данной строки одного символа или некоторого фрагмента подстроки или подпоследовательности.

Есть три формы срезов. Самая простая форма среза: взятие одного символа строки, а именно, `S[i]` — это срез, состоящий
из одного символа, который имеет номер `i`, при этом считая, что нумерация начинается с числа 0. То есть если
`S='Hello'`, то `S[0]=='H'`, `S[1]=='e'`, `S[2]=='l'`, `S[3]=='l'`, `S[4]=='o'`.

Номера символов в строке (а также в других структурах данных: списках, кортежах) называются **индексом**.

Если указать отрицательное значение индекса, то номер будет отсчитываться с конца, начиная с номера `-1`. То есть
`S[-1]=='o'`, `S[-2]=='l'`, `S[-3]=='l'`, `S[-4]=='e'`, `S[-5]=='H'`.


Или в виде таблицы:

+----------+-------+-------+-------+-------+-------+
| Строка S | H     | e     | l     | l     | o     |
+==========+=======+=======+=======+=======+=======+
| Индекс   | S[0]  | S[1]  | S[2]  | S[3]  | S[4]  |
+----------+-------+-------+-------+-------+-------+
| Индекс   | S[-5] | S[-4] | S[-3] | S[-2] | S[-1] |
+----------+-------+-------+-------+-------+-------+

Если же номер символа в срезе строки `S` больше либо равен `len(S)`, или меньше, чем `-len(S)`, то при обращении к этому
символу строки произойдет ошибка `IndexError: string index out of range`.

Срез с двумя параметрами: `S[a:b]` возвращает подстроку из `b-a` символов, начиная с символа c индексом `a`, то есть до
символа с индексом `b`, не включая его. Например, `S[1:4]=='ell'`, то же самое получится если написать `S[-4:-1]`. Можно
использовать как положительные, так и отрицательные индексы в одном срезе, например, `S[1:-1]` —  это строка без первого
и последнего символа (срез начинается с символа с индексом 1 и  заканчиватеся индексом -1, не включая его).

При использовании такой формы среза ошибки `IndexError` никогда не возникает. Например, срез `S[1:5]` вернет строку
`'ello'`, таким же будет результат, если сделать второй индекс очень большим, например, `S[1:100]` (если в строке не
более 5 символов).

Если опустить второй параметр (но поставить двоеточие), то срез берется до конца строки. Например, чтобы удалить из
строки первый символ (его индекс равен 0, то есть взять срез, начиная с символа с индексом 1), то можно взять срез
`S[1:]`, аналогично если опустиить первый параметр, то срез берется от начала строки. То есть удалить из строки
последний символ можно при помощи среза `S[:-1]`. Срез `S[:]` совпадает с самой строкой `S`.

Если задать срез с тремя параметрами `S[a:b:d]`, то третий параметр задает шаг, как в случае с функцией `range`, то есть
будут взяты символы с индексами `a`, `a+d`, `a+2*d` и т.д. При задании значения третьего параметра, равному 2, в срез
попадет кажый второй символ, а если взять значение среза, равное `-1`, то символы будут идти в обратном порядке.

Методы
======

Метод — это функция, применяемая к объекту, в данном случае — к строке. Метод вызывается в виде
`Имя_объекта.Имя_метода(параметры)`. Например, `S.find("e")` — это применение к строке `S` метода `find` с одним
параметром `"e"`.

Метод `find` находит в данной строке (к которой применяется  метод) данную подстроку (которая передается в качестве
параметра). Функция возвращает индекс первого вхождения искомой подстроки. Если же подстрока не найдена, то метод
возвращает значение -1. Например:

.. code-block:: pycon

   >>> S = 'Hello'
   >>> print(S.find('e'))
   1
   >>> print(S.find('ll'))
   2
   >>> print(S.find('L'))
   -1

Аналогично, метод `rfind` возвращает индекс последнего вхождения данной строки («поиск справа»).

.. code-block:: pycon

   >>> S = 'Hello'
   >>> print(S.find('l'))
   2
   >>> print(S.rfind('l'))
   3

Если вызвать метод `find` с тремя параметрами `S.find(T, a, b)`, то поиск будет осуществляться в срезе `S[a:b]`. Если
указать только два параметра `S.find(T, a)`, то поиск будет осуществляться в срезе `S[a:]`, то есть начиная с символа с
индексом `a` и до конца строки. Метод `S.find(T, a, b)` возращает индекс в строке `S`, а не индекс относительно начала
среза.

Метод `replace` заменяет все вхождения одной строки на другую. Формат: `S.replace(old, new)` — заменить в строке `S` все
вхождения подстроки `old` на подстроку `new`. Пример:

.. code-block:: pycon

   >>> 'Hello'.replace('l', 'L')
   'HeLLo'

Если методу `replace` задать еще один параметр: `S.replace(old, new, count)`, то заменены будут не все вхождения, а
только не больше, чем первые `count` из них.

.. code-block:: pycon

   >>> 'Abrakadabra'.replace('a', 'A', 2)
   'AbrAkAdabra'

Метод `count` подсчитывает количество вхождений одной строки в другую строку. Простейшая форма вызова `S.count(T)`
возвращает число вхождений строки `T` внутри строки `S`. При этом подсчитываются только непересекающиеся вхождения,
например:

.. code-block:: pycon

   >>> 'Abracadabra'.count('a')
   4
   >>> ('a' * 100000).count('aa')
   50000

При указании трех параметров `S.count(T, a, b)`, будет выполнен подсчет числа вхождений строки `T` в срез `S[a:b]`.

Упражнение №9: срезы
--------------------

Дана строка. Последовательно на разных строках выведите:

- третий символ этой строки;
- предпоследний символ этой строки;
- первые пять символов этой строки;
- всю строку, кроме последних двух символов;
- все символы с четными индексами (считая, что индексация начинается с 0, поэтому символы выводятся начиная с первого);
- все символы с нечетными индексами, то есть начиная со второго символа строки;
- все символы в обратном порядке.
- все символы строки через один в обратном порядке, начиная с последнего;
- длину данной строки.

Пример:

+-------------+-------------+
| Ввод        | вывод       |
+=============+=============+
| Абракадабра | Абрак       |
+-------------+-------------+
|             | Абракадаб   |
+-------------+-------------+
|             | Аркдба      |
+-------------+-------------+
|             | бааар       |
+-------------+-------------+
|             | арбадакарбА |
+-------------+-------------+
|             | абдкрА      |
+-------------+-------------+
|             | 11          |
+-------------+-------------+

Упражнение №10: количество слов
-------------------------------

Дана строка, состоящая из слов, разделенных пробелами. Определите, сколько в ней слов. Используйте для решения задачи
метод `count`. Пример:

+-------------+-------+
| Ввод        | Вывод |
+=============+=======+
| Hello world | 2     |
+-------------+-------+

Упражнение №11: вставить \*
---------------------------

Получите новую строку, вставив между двумя символами исходной строки символ \*. Выведите полученную строку. Пример:

+--------+------------------+
| Ввод   | Вывод            |
+========+==================+
| python | p\*y\*t\*h\*o\*n |
+--------+------------------+


Упражнение №11: заменить символы, но не все
-------------------------------------------

Замените в строке все появления буквы h на букву H, кроме первого и последнего вхождения. Пример:

+-----------+-----------+
| Ввод      | Вывод     |
+===========+===========+
| aahhhhhbb | aahHHHhbb |
+-----------+-----------+

PEP 8 — руководство по написанию кода на Python
===============================================

PEP 8 создан на основе рекомендаций `Гвидо ван Россума`_ — создателя языка Python.

.. _`Гвидо ван Россума`: https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D1%81%D1%81%D1%83%D0%BC,_%D0%93%D0%B2%D0%B8%D0%B4%D0%BE_%D0%B2%D0%B0%D0%BD


Ключевая идея Гуидо такова: **код читается намного больше раз, чем пишется**. Собственно, рекомендации о стиле написания
кода направлены на то, чтобы улучшить читаемость кода и сделать его согласованным между большим числом проектов. В
идеале, весь код будет написан в едином стиле, и любой сможет легко его прочесть.

На русском можно прочитать про PEP8 тут_, на английском — здесь_.

.. _тут: http://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html
.. _здесь: https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/