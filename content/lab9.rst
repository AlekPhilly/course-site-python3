Арифметика с плавающей запятой
##############################

:date: 2015-10-26 14:31
:status: draft

.. default-role:: code
.. contents:: Содержание

Основы
======

Множество целых чисел бесконечно, но мы всегда можем подобрать такое число бит, чтобы представить любое целое число, возникающее при решении конкретной задачи. Множество действительных чисел не только бесконечно, но еще и непрерывно, поэтому, сколько бы мы не взяли бит, мы неизбежно столкнемся с числами, которые не имеют точного представления. Числа с плавающей запятой — один из возможных способов предсталения действительных чисел, который является компромиссом между точностью и диапазоном принимаемых значений.

Число с плавающей запятой состоит из набора отдельных разрядов, условно разделенных на знак, экспоненту порядок и мантиссу. Порядок и мантисса — целые числа, которые вместе со знаком дают представление числа с плавающей запятой в следующем виде:

.. image:: {filename}/images/lab9/img1.gif

Математически это записывается так:

(-1)\ :sup:`s`\ × M × B\ :sup:`E`\, где s — знак, B-основание, E — порядок, а M — мантисса.

Основание определяет систему счисления разрядов. Математически доказано, что числа с плавающей запятой с базой B=2 (двоичное представление) наиболее устойчивы к ошибкам округления, поэтому на практике встречаются только базы 2 и, реже, 10. Для дальнейшего изложения будем всегда полагать B=2, и формула числа с плавающей запятой будет иметь вид:

(-1)\ :sup:`s`\ × M × 2\ :sup:`E`\

Что такое мантисса и порядок? Мантисса – это целое число фиксированной длины, которое представляет старшие разряды действительного числа. Допустим наша мантисса состоит из трех бит (\|M\|=3). Возьмем, например, число «5», которое в двоичной системе будет равно 101\ :sub:`2`\. Старший бит соответствует 2\ :sup:`2`\=4, средний (который у нас равен нулю) 2\ :sup:`1`\=2, а младший 2\ :sup:`0`\=1. Порядок – это степень базы (двойки) старшего разряда. В нашем случае E=2. Такие числа удобно записывать в так называемом «научном» стандартном виде, например «1.01e+2». Сразу видно, что мантисса состоит из трех знаков, а порядок равен двум. 
Допустим мы хотим получить дробное число, используя те же 3 бита мантиссы. Мы можем это сделать, если возьмем, скажем, E=1. Тогда наше число будет равно 

1,01e+1 = 1×2\ :sup:`1`\+0×2\ :sup:`0`\+1×2\ :sup:`-1`\=2+0,5=2,5

Здесь, поскольку E=1, степень двойки первого разряда (который идет перед запятой), равна «1». Два других разряда, расположенных правее (после запятой), обеспечивают вклад 2\ :sup:`E-1`\ и 2\ :sup:`E-2`\ (2\ :sup:`0`\ и 2\ :sup:`-1`\ соответственно). Очевидно, что регулируя E одно и то же число можно представить по-разному. Рассмотрим пример с длиной мантиссы \|M\|=4. Число «2» можно представить в следующем виде: 

2 = 10 (в двоичной системе) = 1.000e+1 = 0.100e+2 = 0.010e+3. (E=1, E=2, E=3 соответственно)

Обратите внимание, что одно и то же число имеет несколько представлений. Это не удобно для оборудования, т.к. нужно учитывать множественность представлния при сравнении чисел и при выполнении над ними арифметических операций. Кроме того, это не экономично, поскольку число представлений — конечное, а повторения уменьшают множество чисел, которые вообще могут быть представлены. Поэтому уже в самых первых машинах начали использовать трюк, делая первый бит мантиссы всегда положительным. Такое предаставление назвали нормализованным. 

.. image:: {filename}/images/lab9/img2.gif

Это экономит один бит, так как неявную единицу не нужно хранить в памяти, и обеспечивает уникальность представления числа. В нашем примере «2» имеет единственное нормализованное представление («1.000e+1»), а мантисса хранится в памяти как «000», т.к. старшая единица подразумевается неявно. Но в нормализованном представлении чисел возникает новая проблема — в такой форме невозможно представить ноль. 

Качество решения задач во многом зависит от выбора представления чисел с плавающей запятой. Мы плавно подошли к проблеме стандартизации такого представления.

Cтандарт IEEE754
================

Числа с плавающей запятой в IEEE754 представлены в виде знака (s), мантиссы (M) и порядка (E) следующим образом:

(-1)\ :sup:`s`\ × 1.M × 2\ :sup:`E`\

В числах одинарной точности (single) порядок состоит из 8 бит, а мантисса – из 23. Эффективный порядок определяется как E\ :sup:`-127`\. Например, число 0,15625 будет записано в памяти как

.. image:: {filename}/images/lab9/img3.gif

В этом примере:

* Знак s=0 (положительное число)
* Порядок E=01111100\ :sub:`2`\-127\ :sub:`10`\ = -3
* Мантисса M = 1.01\ :sub:`2`\ (первая единица не явная)

В результате наше число F = 1.012e-3 = 2\ :sup:`-3`\+2\ :sup:`-5`\ = 0,125 + 0,03125 = 0,15625

Подробнее: Здесь мы имеем дело с двоичным представлением числа «101» со сдвигом запятой на несколько разрядов влево. 1,01 — это двоичное представление, означающее 1×2\ :sup:`0`\ + 0×2\ :sup:`-1`\ + 1×2\ :sup:`-2`\. Сдвинув запятую на три позиции влево получим 1,01e-3 = 1×2\ :sup:`-3`\ + 0×2\ :sup:`-4`\ + 1×2\ :sup:`-5`\ = 1×0,125 + 0×0,0625 + 1×0,03125 = 0,125 + 0,03125 = 0,15625.

В `стандарте 2008 года`_ кроме чисел одинарной и двойной точности описаны перспективные числа **четверной точности** (Quadruple precision).

.. _`стандарте 2008 года`: https://ru.wikipedia.org/wiki/IEEE_754-2008

Числа с половинной, двойной и четверной точностью обладают теми же особенностями, но имеют другой диапазон порядка и мантиссы.

+--------------+----------------------+----------------+----------------+-------------------+------------------------------------+
| Тип          | Название             | Бит в мантиссе | Бит экспоненты | Десятичных знаков | Максимальная десятичная экспонента |
+==============+======================+================+================+===================+====================================+
| binary16     | Half precision       | 11             | 5              | 3.31              | 4.51                               |
+--------------+----------------------+----------------+----------------+-------------------+------------------------------------+
| binary32     | Single precision     | 24             | 8              | 7.22              | 38.23                              |
+--------------+----------------------+----------------+----------------+-------------------+------------------------------------+
| **binary64** | **Double precision** | 53             | 11             | **15.95**         | **307.95**                         |
+--------------+----------------------+----------------+----------------+-------------------+------------------------------------+
| binary128    | Quadruple precision  | 113            | 15             | 34.02             | 4931.77                            |
+--------------+----------------------+----------------+----------------+-------------------+------------------------------------+

**Внимание! В Python3 стандартный тип float соответствует числам двойной точности.**

В стандарте 2008 года описаны также десятичные (decimal) числа с плавающей запятой, но мы их изучать не будем.

Специальные числа: ноль, бесконечность и неопределенность
---------------------------------------------------------

В IEEE754 число «0» представляется значением с порядком, равным E=E\ :sub:`min`\-1 (для single это -127) и нулевой мантиссой. Введение нуля как самостоятельного числа (т.к. в нормализованном представлении нельзя представить ноль) позволило избежать многих странностей в арифметике. И хоть операции с нулем нужно обрабатывать отдельно, обычно они выполняются быстрее, чем с обычными числами. 

Также в IEEE754 предусмотрено представление для специальных чисел, работа с которыми вызывает исключение. К таким числам относится бесконечность (±∞) и неопределенность (NaN). Эти числа позволяет вернуть адекватное значение при переполнении. Бесконечности представлены как числа с порядком E=E\ :sub:`max`\+1 и нулевой мантиссой. Получить бесконечность можно при переполнении и при делении ненулевого числа на ноль. Бесконечность при делении разработчики определили исходя из существования пределов, когда делимое и делитель стремиться к какому-то числу. Соответственно, c/0==±∞ (например, 3/0=+∞, а -3/0=-∞), так как если делимое стремиться к константе, а делитель к нулю, предел равен бесконечности. При 0/0 предел не существует, поэтому результатом будет неопределенность.

Неопределенность или NaN (от not a number) – это представление, придуманное для того, чтобы арифметическая операция могла всегда вернуть какое-то не бессмысленное значение. В IEEE754 NaN представлен как число, в котором E=E\ :sub:`max`\+1, а мантисса не нулевая. Любая операция с NaN возвращает NaN. При желании в мантиссу можно записывать информацию, которую программа сможет интерпретировать. Стандартом это не оговорено и мантисса чаще всего игнорируется. 

Как можно получить NaN? Одним из следующих способов:

* ∞+(- ∞)
* 0 × ∞
* 0/0, ∞/∞
* sqrt(x), где x<0

По определению NaN ≠ NaN, поэтому, для проверки значения переменной нужно просто сравнить ее с собой.

Зачем нулю знак (или +0 vs -0)
++++++++++++++++++++++++++++++

Любознательный читатель вероятно уже замелил заметил, что в описанном представлении чисел с плавающей запятой существует два нуля, которые отличаются только знаком. Так, 3·(+0)=+0, а 3·(-0)=-0. Но при сравнении +0=-0. В стандарте знак сохранили умышленно, чтобы выражения, которые в результате переполнения или потери значимости превращаются в бесконечность или в ноль, при умножении и делении все же могли представить максимально корректный результат. Например, если бы у нуля не было знака, выражение 1/(1/x)=x не выполнялось бы верно при x=±∞, так как 1/∞ и 1/-∞ равны 0.

Еще один пример: 
(+∞/0) + ∞ = +∞, тогда как (+∞/-0) +∞ = NaN

Чем бесконечность в данном случае лучше, чем NaN? Тем, что если в арифметическом выражении появился NaN, результатом всего выражения всегда будет NaN. Если же в выражении встретилась бесконечность, то результатом может быть ноль, бесконечность или обычное число с плавающей запятой. Например, 1/∞=0.

Денормализованные числа
-----------------------

Что такое субнормальные денормализованные (subnormal) числа рассмотрим на простом примере. Пусть имеем нормализованное представление с длиной мантиссы \|M\|=2 бита (+ один бит нормализации) и диапазоном значений порядка -1≤E≤2. В этом случае получим 16 чисел:

.. image:: {filename}/images/lab9/img4.gif

Крупными штрихами показаны числа с мантиссой, равной 1,00. Видно, что расстояние от нуля до ближайшего числа (0 - 0,5) больше, чем от этого числа к следующему (0,5 - 0,625). Это значит, что разница двух любых чисел от 0,5 до 1 даст 0, даже если эти числа не равны. Что еще хуже, в пропасть между 0,5 и 0 попадает разница чисел, больших 1. Например, «1,5-1,25=0» (см. картинку).

В «околонулевую яму» подпадает не каждая программа. Согласно статистике 70-х годов в среднем каждый компьютер сталкивался с такой проблемой один раз в месяц. Учитывая, что компьютеры приобретали массовость, разработчики IEEE754 посчитали эту проблему достаточно серьезной, чтобы решать ее на аппаратном уровне. Предложенное ими решение состояло в следующем. Мы знаем, что при E=E\ :sub:`min`\-1 (для float это «-127») и нулевой мантиссе число считается равным нулю. Если же мантисса не нулевая, то число считается не нулевым, его порядок полагается E=E\ :sub:`min`\, причем неявный старший бит мантиссы полагается равным нулю. Такие числа называются денормализованными.

Строго говодя, числа с плавающей запятой теперь имеют вид:

(-1)\ :sup:`s`\ × 1.M × 2\ :sup:`E`\, если E\ :sub:`min`\≤E≤E\ :sub:`max`\ (нормализованные числа)

(-1)\ :sup:`s`\ × 0.M × 2\ :sup:`E`\ :sub:`min`\ \, если E=E\ :sub:`min`\-1. (денормализованные числа)

Вернемся к примеру. Наш E\ :sub:`min`\=-1. Введем новое значение порядка, E=-2, при котором числа являются денормализованными. В результате получаем новое представление чисел:

.. image:: {filename}/images/lab9/img5.gif

Интервал от 0 до 0,5 заполняют денормализованные числа, что дает возможность не проваливаться в 0 рассмотренных выше примерах (0,5-0,25 и 1,5-1,25). Это сделало представление более устойчиво к ошибкам округления для чисел, близких к нулю. 

Но роскошь использования денормализованного представления чисел в процессоре не дается бесплатно. Из-за того, что такие числа нужно обрабатывать по-другому во всех арифметических операциях, трудно сделать работу в такой арифметике эффективной. Это накладывает дополнительные сложности при реализации АЛУ в процессоре. И хоть денормализованные числа очень полезны, они не являются панацеей и за округлением до нуля все равно нужно следить. Поэтому эта функциональность стала камнем преткновения при разработке стандарта и встретила самое сильное сопротивление. 

Ошибки округления
-----------------

С ошибками из-за погрешностей округления в современной арифметике с плавающей запятой встретиться сложно, особенно если использовать двойную точность. Правило округления в стандарте IEEE754 говорит о том, что результат любой арифметической операции должен быть таким, как если бы он был выполнен над точными значениями и округлен до ближайшего числа, представимого в этом формате. Это требует от CPU дополнительных усилий и в некоторых языках программирования может быть отключено специальными опцями компилятора (такие как «-ffast-math» в gcc). 

Особенности округления в IEEE754
++++++++++++++++++++++++++++++++

Округление до ближайшего в стандарте сделано не так как мы привыкли. Математически показано, что если 0,5 округлять до 1 (в большую сторону), то существует набор операций, при которых ошибка округления будет возрастать до бесконечности. Поэтому в IEEE754 применяется правило округления до четного. Так, 12,5 будет округлено до 12, а 13,5 – до 14.
Самая опасная операция с точки зрения округления в арифметике с плавающей запятой — это вычитание. При вычитании близких чисел значимые разряды могут потеряться, что
может в разы увеличить относительную погрешность.

Для многих широко распространенных математических формул математики разработали специальную форму, которая позволяет значительно уменьшить погрешность при округлении. Например, расчёт формулы «x\ :sup:`2`\ -y\ :sup:`2`\ » лучше вычислять используя формулу «(x-y)(x+y)».

Неассоциативность арифметических операций
-----------------------------------------

В арифметике с плавающей запятой правило (a*b)*c = a*(b*c) не выполняется для любых арифметических операций. Например,

(10\ :sup:`20`\  + 1) - 10\ :sup:`20`\  = 0

(10\ :sup:`20`\  - 10\ :sup:`20`\ ) + 1 = 1

Числовые константы
------------------

Помните, что не все десятичные числа имеют двоичное представление с плавающей запятой. Например, число «0,2» в одинарной точности будет представлено как «0,200000003». Соответственно, «0,2 + 0,2 ≈ 0,4». Абсолютная погрешность в отдельном случае может и не высока, но если использовать такую константу в цикле, можем получить весомую накопленную погрешность.

Итак, представление чисел в виде **float** и последующие арифметические операции с ними неминуемо приводит к накоплению ошибки.

Упражнение №1
=============

Пусть последовательность x\ :sub:`n`\  определена так:

.. image:: {filename}/images/lab9/img6.png


а) Напишите программу которая выводит x\ :sub:`30`\.

б) Пользуясь математическим анализом найдите аналитическое значение предела указанной последовательности.

в) Обьясните результат, полученный в пункте а).


Модуль Decimal
==============

Особенно критично люди (почему-то) относятся к арифметическим ошибкам в области подсчёта денег.
Когда деньги уходят в никуда либо появляются ниоткуда, бухгалтерия ``встаёт на уши`` и разработчик получает очень строгий выговор.
Поэтому деньги нельзя хранить в виде числа с плавающей запятой.

Если в языке программирования нет типов данных с фиксированной запятой, можно выйти из положения и хранить деньги в виде целого числа, подразумевая копейки (иногда доли копеек).

В Python 3 можно использовать тип чисел Decimal, который ничего не теряет просто так. Decimal представлен в памяти как знак, набор цифр и положение десятичной точки — в результате нет никакого округления при переводе из двоичной дроби в десятичную и обратно.

Использование очень простое:

.. code-block:: python

	>>> from decimal import Decimal
	>>> Decimal("4.31")
	Decimal('4.31')
	>>> Decimal("4.31") + Decimal("1.10")
	Decimal('5.41')

Но при этом есть некоторые тонкости:

.. code-block:: python

	>>> Decimal("1.10") / 3
	Decimal('0.3666666666666666666666666667')

Дело в том, что помимо Decimal есть еще и Context. По умолчанию у него точность в 28 чисел в дробной части, что для валюты слишком много. Настроим контекст на 2 знака после запятой:

.. code-block:: python

	>>> from decimal import Decimal, getcontext
	>>> getcontext().prec = 2
	>>> Decimal('1.10') / 3
	Decimal('0.37')

Правила округления тоже задаются контекстом. По умолчанию это ROUND_HALF_UP — округлять вверх, если цифра пять и больше. Как в школе учили. Можно настроить и другой способ — читайте документацию. Еще можно указать, чтобы при разных ситуациях (потеря точности или бесконечность в результате, например) генерировалось исключение а не происходило округление. Кому надо — пусть изучает эту самую документацию, ключевое слово trap.

Вернемся к наиболее распространенным задачам.

Что делать, если часть вычислений нужно проводить с точностью «до копеек», а некоторые (например, то же сведение баланса и подсчет налогов) — до сотых долей копеек?

Наиболее практичный способ — создание своего контекста и применение его в with statement:

.. code-block:: python

	>>> from decimal import Context, localcontext
	>>> with localcontext(Context(4)):
	...     print(repr(Decimal("1.10") / 3))
	Decimal('0.3667')

Округление:

.. code-block:: python

	>>> Decimal('1.12').quantize(Decimal('0.1'))
	Decimal('1.1')
	>>> Decimal('1.16').quantize(Decimal('0.1'))
	Decimal('1.2')

Внимание! Округлять можно только до той максимальной точности, которая позволена текущим контекстом. Сейчас у нас глобальный контекст имеет точность 2.

.. code-block:: python

	>>> getcontext().prec = 2
	>>> Decimal('1.10').quantize(Decimal('0.000001'))
	Traceback (most recent call last):
	...
	decimal.InvalidOperation: quantize result has too many digits for current contex

Модуль fractions
================

Модуль fractions реализует класс **Fraction** и предназначен для точных вычислений в обыкновенных дробях.

.. code-block:: python

	>>> from fractions import Fraction
	>>> Fraction(7, 71) * 71 == 7
	True

Не все обыкновенные дроби имеют точное конечное представление, укладывающееся в границы float.

.. code-block:: python

	>>> 7/71*71 == 7
	False

Инициализировать экземпляр класса Fraction можно по-разному:

.. code-block:: python

	class fractions.Fraction(numerator=0, denominator=1)

	class fractions.Fraction(other_fraction)

	class fractions.Fraction(float)

	class fractions.Fraction(decimal)

	class fractions.Fraction(string)

Класс, представляющий собой рациональные числа. Экземпляр класса можно создать из пары чисел (числитель, знаменатель), из другого рационального числа, числа с плавающей точкой, числа типа decimal.Decimal, и из строки, представляющей собой число.

.. code-block:: python

	>>> from fractions import Fraction
	>>> Fraction(1, 3)
	Fraction(1, 3)
	>>> Fraction(2, 6)
	Fraction(1, 3)
	>>> Fraction(100)
	Fraction(100, 1)
	>>> Fraction()
	Fraction(0, 1)
	>>> Fraction('3/7')
	Fraction(3, 7)
	>>> Fraction(' 3/7 ')
	Fraction(3, 7)
	>>> Fraction('3.1415')
	Fraction(6283, 2000)
	>>> Fraction(3.1415)
	Fraction(7074029114692207, 2251799813685248)

Необходимо заметить, что, поскольку числа с плавающей точкой не совсем точны, получающееся рациональное число может отличаться от того, что мы хотим получить. Можете поделить столбиком 7074029114692207 на 2251799813685248 и убедиться :-) (а можно воспользоваться модулем decimal).

Рациональные числа можно, как int и float, складывать, умножать, делить...

.. code-block:: python

	>>> from fractions import Fraction
	>>> a = Fraction(1, 7)
	>>> b = Fraction(1, 3)
	>>> a + b
	Fraction(10, 21)
	>>> a - b
	Fraction(-4, 21)
	>>> a * b
	Fraction(1, 21)
	>>> a / b
	Fraction(3, 7)
	>>> a % b
	Fraction(1, 7)
	>>> b % a
	Fraction(1, 21)
	>>> a ** b
	0.5227579585747102
	>>> abs(a - b)
	Fraction(4, 21)

Fraction.limit_denominator(max_denominator=1000000) - ближайшее рациональное число со знаменателем не больше данного.


.. code-block:: python

	>>> from fractions import Fraction
	>>> a = Fraction(3.1415)
	>>> a
	Fraction(7074029114692207, 2251799813685248)
	>>> a.limit_denominator()
	Fraction(6283, 2000)

Однако, будет лучше, если вообще не возникало инициализации float-ом. Начальное значение Fraction (как и Decimal) всегда лучше задать строковым литералом:

.. code-block:: python

	>>> from fractions import Fraction
	>>> a = Fraction('3.1415')
	>>> a
	Fraction(6283, 2000)


Также, помимо класса рациональных чисел, модуль fractions предоставляет эффективную функцию для нахождения наибольшего общего делителя, НОД чисел.

**fractions.gcd(a, b)** - наибольший общий делитель чисел a и b.

.. code-block:: python

	>>> from fractions import gcd
	>>> gcd(1, 5)
	1
	>>> gcd(1000, 3)
	1
	>>> gcd(1001, 99)
	11
	>>> gcd(0, 2)
	2
	>>> gcd(0, 0)
	0
