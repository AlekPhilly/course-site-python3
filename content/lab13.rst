Проект «Обработка матриц»
#########################

:date: 2015-11-23 10:30
:status: draft

.. :lecture_link: https://youtu.be/BmKd1aqrnRg

.. default-role:: code
.. contents:: Содержание

API
===

При написании больших программ зачастую возникает потребность в использовании модулей, написанных сторонними
разработчиками. Примером таких модулей вполне могут служить модули, входящие в стандартную библиотеку языка Python
(такие как os, sys, math и другие). Для того, чтобы использование этих модулей было возможным, программисту должна быть
предоставлена информация о том, какие классы и функции определены в модуле, каково их предназначение, какие
данные они принимают на вход, а какие возвращают. В таких случаях говорят, что модуль предоставляет некоторый
**интерфейс для взаимодействия** или **API** (application programming interface). Какждый раз, когда мы используем
какую-то стороннюю библиотеку по сути мы взаимодействуем с ней посредством интерфейса.

В качестве примера расмотрим работу визового центра. Визовый центр можно представить себе как `модуль`, в котором среди
прочего определена функция получения визы для поездки в другую страну. Для получения визы требуется подать определённый
(вполне конкретный) пакет документов — это `аргументы` функции получения визы. По факту обращения за визой мы ожидаем
получить один из двух результатов: либо визу (`результат`, возвращаемых функцией), либо отказ в получении визы
(`сообщение об ошибке`). По сути, это и есть `API` нашего визового центра.

Резюмируя, `API` — это информация о доступных классах и функциях, а также их параметрах и возвращаемых значениях.

Цель данной работы — написать программу, предоставляющую определённый `API`. Но для начала рассмотрим несколько
механизмов языка Python, которые будут весьма полезны при написании этой практической работы.


Параметры функций
=================

Именованные параметры
---------------------

До этого все функции, которые мы рассматривали, описывались так:

.. code-block:: python

   def func(a, b, c):
       pass

Соответственно, для вызова использовалась конструкция вида

.. code-block:: python

   func(1, 2, 3)

В случае, когда функция имеет большое число аргументов, бывает удобным указать имя аргумента непосредственно при вызове
функции:

.. code-block:: python

   func(a=1, b=2, c=3)

По своему смыслу такой вызов полностью эквивалентен предыдущему, но является более наглядным. Такие аргументы функции
называются **именованными** (**keyword arguments**), поскольку перед каждым аргументом указывается его имя. При этом
обязательно должны быть перечислены все аргументы, но их порядок может быть произвольным:

.. code-block:: python

    # правильный вызов
    func(a=1, b=2, c=3)
    # и это правильный
    func(a=1, c=3, b=2)
    # и вот этот
    func(b=2, c=3, a=1)
    # и даже этот
    func(c=3, b=2, a=1)

Именованные аргументы могут быть использованы для написания функций, часть аргументов которых являются необязательными.
Например, так может выглядеть функция, вычисляющая максимальный из своих аргументов:

.. code-block:: python

   def _max(a, b=None, c=None, d=None):
       if b is None and c is None and d is None:
            return a
        elif c is None and d is None:
            return a if a > b else b
        else:
            return _max(_max(a, b), _max(c, d))

В этом примере функция `_max` имеет только один обязательный параметр `a`, остальные — являются необязательными.

Соответственно, такая функция будет работать при разном числе аргументов:

.. code-block:: pycon

   >>> _max(1)
   1
   >>> _max(1, 2)
   2
   >>> _max(1, 2, 3)
   3
   >>> _max(1, 2, 3, 4)
   4
   >>> _max(2, 5)
   5
   >>> _max(2, 10, 5)
   10

Но вот попытка вызвать эту функцию таким образом:

.. code-block:: pycon

   >>> _max(2, 10, d=5)
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
     File "<stdin>", line 7, in _max
     File "<stdin>", line 5, in _max
   TypeError: unorderable types: NoneType() > int()

приведёт к ошибке, поскольку функция не обрабатывает ситуацию, когда параметр `c` пропущен.

Помимо именованных параметров этом примере также используется ещё одна синтаксическая конструкция — **тернарный
оператор** `<выражение, если условие истинно> if <условие> else <выражение, если условие ложно>`.

Список параметров произвольной длины
------------------------------------

Функция вычисления максимума, написанная в прошлом примере принимает только четыре параметра, при этом мы нобязаны
указывать параметры по порядку (`a`, `a` и `b` и т.д.). Более приемлемым вариантом было бы использование списка
аргументов проивзвольной длины:

.. code-block:: python

   def _max(*args):
       m = args[0]
       for x in args[1:]:
           if x > m:
               m = x
       return m

Такая функция принимает произвольное число параметров, которые при вызове запаковываются в кортеж `args`, поэтому все
варианты вызова ниже являются корректными:

.. code-block:: pycon

   >>> _max(1)
   1
   >>> _max(1, 2, 3)
   3
   >>> _max(1, 100, 3)
   100
   >>> _max(1, 100, 3, 500)
   500
   >>> _max(9000, 1, 100, 3, 500)
   9000
   >>> _max(9000, 1, 100, 3, 500, 100500)
   100500

Произвольное количество именованных параметров
----------------------------------------------

В некоторых ситуациях бывает необходима функция, которая принимает произвольное количество именованных параметров. Для
этого в языке Python используется следующая синтаксическая коснтрукция:

.. code-block:: python

   def func(**kwargs):

Такой функции можно передавать произвольное количество именованных параметров, причём все они будут упакованы в словарь
`kwargs`.

Естественно, описанные выше способы можно комбинировать. Рассмотрим пример функции, принимающей один обязательный
параметр, один необязательный, а также произвольное число как неименованных, так и именованных параметров:

.. code-block:: python

   def func(a, b=None, *args, **kwargs):
       print("a", a)
       print("b", b)
       print("Positional args: " + str(args))
       print("Keyword args: " + str(kwargs))

Такую функцию можно вызывать совершенно различными способами:

.. code-block:: pycon

   >>> func(1)
   a 1
   b None
   Positional args: ()
   Keyword args: {}
   >>> func(1, 2)
   a 1
   b 2
   Positional args: ()
   Keyword args: {}
   >>> func(1, 2, 3)
   a 1
   b 2
   Positional args: (3,)
   Keyword args: {}
   >>> func(1, 2, 3, 4)
   a 1
   b 2
   Positional args: (3, 4)
   Keyword args: {}
   >>> func(1, 2, 3, 4, aaa=5)
   a 1
   b 2
   Positional args: (3, 4)
   Keyword args: {'aaa': 5}
   >>> func(1, 2, 3, 4, aaa=5, bbb=7)
   a 1
   b 2
   Positional args: (3, 4)
   Keyword args: {'bbb': 7, 'aaa': 5}

Исключения
==========

Ни одна программа не обходится без ошибок. Иногда эти ошибки присутствуют в алгоритмах, выполняющих те или иные функции,
а иногда происходят просто при неправильном использовании этих алгоритмов. В качестве примера рассмотрим написанную нами
ранее функцию, возвращающую максимальный из своих аргументов:

.. code-block:: python

   def _max(*args):
       m = args[0]
       for x in args[1:]:
           if x > m:
               m = x
       return m

Попробуем вызвать её с пустым списком аргументов:

.. code-block:: pycon

   >>> _max()
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
     File "<stdin>", line 2, in _max
   IndexError: tuple index out of range

Мы получили ошибку, поскольку из пустого кортежа нельзя извлечь первый элемент. В принципе, мы можем переписать нашу
программу так, чтобы при передаче пустого списка параметров функция возвращала какое-то значение. Но какое? В некоторых
ситуациях выбор такого значения вполне очевиден, в других — не очень. В нашей конкретной ситуации мы вполне можем
вернуть значение `None`. Но какое значение нам вернуть в ситуации, когда параметры функции переданы, но они являются
несравнимыми между собой?

.. code-block:: python

    _max(123, "azaza")

Эту проблему опять же можно решить, например, вернув `None` и выставив соотвествующее значение какой-нибудь глобальной
переменной. Но гораздо проще и удобнее прервать выполнение программы, вернв управление вызывающему блоку и сообщив ему о
том, что произошла ошибка. Для этого язык Python, как и многие современные языки, поддерживает маханизм
**исключений** (**exceptions**).

Генерация исключений
--------------------

Для генерации исключений в языке Python существует оператор `raise`:

.. code-block:: pycon

   >>> raise Exception("Oops")
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   Exception: Oops

В качестве параметра оператор `raise` принимает объект, тип которого является дочерним по отношению к базовому классу
для всех исключений — `BaseException`. Такой объект обычно содержит поля, каким-то образом характеризующие тип
произошедшей ошибки.

Так выглядит полный список стандартных типов исключений:

.. code-block:: text

   BaseException
    +-- SystemExit
    +-- KeyboardInterrupt
    +-- GeneratorExit
    +-- Exception
         +-- StopIteration
         +-- StopAsyncIteration
         +-- ArithmeticError
         |    +-- FloatingPointError
         |    +-- OverflowError
         |    +-- ZeroDivisionError
         +-- AssertionError
         +-- AttributeError
         +-- BufferError
         +-- EOFError
         +-- ImportError
         +-- LookupError
         |    +-- IndexError
         |    +-- KeyError
         +-- MemoryError
         +-- NameError
         |    +-- UnboundLocalError
         +-- OSError
         |    +-- BlockingIOError
         |    +-- ChildProcessError
         |    +-- ConnectionError
         |    |    +-- BrokenPipeError
         |    |    +-- ConnectionAbortedError
         |    |    +-- ConnectionRefusedError
         |    |    +-- ConnectionResetError
         |    +-- FileExistsError
         |    +-- FileNotFoundError
         |    +-- InterruptedError
         |    +-- IsADirectoryError
         |    +-- NotADirectoryError
         |    +-- PermissionError
         |    +-- ProcessLookupError
         |    +-- TimeoutError
         +-- ReferenceError
         +-- RuntimeError
         |    +-- NotImplementedError
         |    +-- RecursionError
         +-- SyntaxError
         |    +-- IndentationError
         |         +-- TabError
         +-- SystemError
         +-- TypeError
         +-- ValueError
         |    +-- UnicodeError
         |         +-- UnicodeDecodeError
         |         +-- UnicodeEncodeError
         |         +-- UnicodeTranslateError
         +-- Warning
              +-- DeprecationWarning
              +-- PendingDeprecationWarning
              +-- RuntimeWarning
              +-- SyntaxWarning
              +-- UserWarning
              +-- FutureWarning
              +-- ImportWarning
              +-- UnicodeWarning
              +-- BytesWarning
              +-- ResourceWarning

Мы не будет подробно останавливаться на значении каждого из этих типов, а сразу перейдём к вопросам обработки
исключений.

Обработка исключений
--------------------

Для обработки исключений используется блок `try..except`. Например:

.. code-block:: pycon

   >>> def func_with_exception(a):
   ...     print('Внутри func_with_exception')
   ...     if a == 0:
   ...         print('Перед raise')
   ...         raise Exception()
   ...         print('После raise, вы никогда не увидите эту строчку')
   ...
   ...     print('Перед return')
   ...     return a
   ...
   >>> print('Этот вызов не приведёт к генерации исключения')
   Этот вызов не приведёт к генерации исключения
   >>> func_with_exception(1)
   Внутри func_with_exception
   Перед return
   1
   >>>
   >>> print('А этот приведёт, но мы его перехватим')
   А этот приведёт, но мы его перехватим
   >>> try:
   ...     func_with_exception(0)
   ... except Exception as e:
   ...     print('Исключение перехвачено')
   ...
   Внутри func_with_exception
   Перед raise
   Исключение перехвачено
   >>> print('Этот вызов тоже приведёт к генерации исключения, но мы не будем его перехватывать')
   Этот вызов тоже приведёт к генерации исключения, но мы не будем его перехватывать
   >>> func_with_exception(0)
   Внутри func_with_exception
   Перед raise
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
     File "<stdin>", line 5, in func_with_exception
   Exception

Этот пример достаточно наглядно демонстрирует, как именно происходит процесс обработки исключений. После того, как
исключение сгенерировано, интерпретатор пытается найти ближайший блок `try..except`, внутри которого это исключение было
создано. Подходящим считается тот блок, в котором присутствует часть `except X as x`, где X — имя класса или
совпадающего с классом объекта исключения или являющегося для него родительским. Если такой блок найден, то управление
передаётся в него, если же нет, то поиск такого блока продолжается на уровень выше по **стеку вызовов** — то есть в той
функции, что вызвала функцию, в которой исключение было сгенерировано. Так продолжается до тех пор, пока обработчик не
будет найдет. В самом крайнем случае сработает системный обработчик, который выведет на экран информацию об исключении и
аварийно завершит программу.

Иногда бывает необходимо разместить несколько блоков `except` для обработки разных типов исключений. А ещё иногда
требуется выполнить какие-то действия в независимости от того, произошло действие или нет — в такой ситуации
используется блок `finally`. Пример:

.. code-block:: pycon

   >>> def divide(a, b):
   ...     r = None
   ...     try:
   ...         print('Окей, с собираюсь выполнить деление %s на %s' % (str(a), str(b)))
   ...         r = a / b
   ...     except ZeroDivisionError as e:
   ...         print('Кажется, кто-то пытается поделить на ноль')
   ...     except TypeError as e:
   ...         print('Кажется, кто-то пытается поделить то, что вообще-то делить нельзя')
   ...     finally:
   ...         print('В любом случае, я сделал то, что от меня хотели. Или не сделал. Я не знаю. Ответ: ' + str(r))
   ...         return r
   ...
   >>> divide(2, 2)
   Окей, с собираюсь выполнить деление 2 на 2
   В любом случае, я сделал то, что от меня хотели. Или не сделал. Я не знаю. Ответ: 1.0
   1.0
   >>> divide(2, 0)
   Окей, с собираюсь выполнить деление 2 на 0
   Кажется, кто-то пытается поделить на ноль
   В любом случае, я сделал то, что от меня хотели. Или не сделал. Я не знаю. Ответ: None
   >>> divide(2, 'пельмень')
   Окей, с собираюсь выполнить деление 2 на пельмень
   Кажется, кто-то пытается поделить то, что вообще-то делить нельзя
   В любом случае, я сделал то, что от меня хотели. Или не сделал. Я не знаю. Ответ: None

Видим, что несмотря на две попытки вызвать операцию деления с заведомо некорректными аргументами выполнение
программы завершилось штатно, потому что все исключения были обработаны в блоке `try..except..finally`.

Упражнение №1: обработка матриц
===============================

Как было сказано в начале, цель этой работы — написать модуль, предоставляющий определённый `API`, а именно
необходимо написать `модуль`_, в котором реализовать различные операции над матрицами.

.. _`модуль`: {filename}/extra/lab13/matrix.m.html

При этом, необходимо строго соблюдать `API`, написанный в документации, посколько для вашей реализации заботливыми
руками подготовлен набор `тестов`_, проверяющий корректность реализации.

.. _`тестов`: {filename}/code/lab13/tests.py

Все тесты разбиты на две группы: простые тесты (SimpleTests) и не очень простые тесты (NotSoSimpleTests). Задача состоит
в том, чтобы написать библиотеку работы с матрицами, для которой проходило бы как можно больше тестов. В идеале — все.

.. image:: {filename}/images/lab13/pycharm_tests.png
   :width: 421px

План выполнения работы:

#. Скачайте файл с `тестами`_.
#. В той же папке, где лежит файл с тестами, создайте файл `matrix.py`
#. Напишите в нём реализацию класса `Matrix` с необходимыми методами, которые описаны в документации. Для определения
   того, какое поведение ожидается от метода, внимательно посмотрите текст соответствующего теста.
#. Для тестирования запустите файл `tests.py` при помощи команды `python3 tests.py`.

.. _`тестами`: {filename}/code/lab13/tests.py