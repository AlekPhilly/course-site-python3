Консольные утилиты
##################

:date: 2016-02-08
:lecture_link: https://youtu.be/dHzRaseQPjE
:status: draft

.. default-role:: code
.. contents:: Содержание

Параметры командной строки
==========================

Во всех предыдущих практических работах для ввода значений пользователем
использовался вызов функции `input` или чтение из файла. Иногда оказывается
удобным другой подход — передача данных при помощи **параметров командной
строки**. Т.е. при вызове программы указывается несколько строковых параметров, к
которомы в процессе выполнения можно получить доступ:

.. code-block:: bash

    python3 ./args.py параметр_1 параметр_2 "параметр 3 с пробелами"

Python, следуя общепринятым правилам, предоставляет доступ к параметрам
командной строки посредством переменной `argv`, определённой в модуле `sys`. Вот
так выглядит программа, которая выводит на экрах список переданных ей параметров
командной строки:

.. code-block:: python

   # импортируем модуль
   import sys

   # выводим на экран список всех аргументов
   for arg in sys.argv:
       print(arg)

А так выглядит результат запуска этой программы с различными параметрами:

.. code-block:: plain

   ❯ python ./args.py параметр-1 параметр-2
   ./args.py
   параметр-1
   параметр-2
   ❯ python ./args.py параметр-1 параметр-2 "параметр 3 с пробелами"
   ./args.py
   параметр-1
   параметр-2
   параметр 3 с пробелами

Как видно из примера, список `sys.argv` всегда имеет хотя бы одно значение —
название запущенной программы. Если переданы дополнительные параметры, то они,
соответственно, содержатся в оставшейся части списка (`sys.argv[1:]`).


Упражнение №1
-------------

Напишите программу, выводящую количество параметров командной строки, длина
которых кратна 3. Первый параметр (т.е. имя программы) не учитывайте.

Разбор параметров командной строки
==================================

Консольные программы принимают большое количество параметров, поэтому для удобства
передачи и разбора вводятся определённые соглашения.
Мы будем использовать `соглашения проекта GNU`__:

.. __: http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html

Типы параметров командной строки:

* **опции** (они же `command-line switches`) — используются для изменения поведения
  программы. 

* **позиционные параметры** (`positional arguments`) —  обычно указываются в
  конце списка параметром; предполагается, что при помощи этих аргументов
  передаются параметры, которые не меняют поведение программы

Опции могут отличаться по длине:

* длинные (`long`) — начинаются с двух минусов, содержат в имени более
  одного символа (например, `--help`)
* короткие (`short`) — начинаются с одного минуса, содержат в имени ровно
  один символ (например, `-h`)

И по количеству параметров опции:

* без параметров (например, `-c`, `--verbose`)
* с параметрами — после имени опции следует параметр этой опции
  (например, `-o rw`, `--verbose 99`)
  
Особый параметр `--` используется для отделения опций от позиционных
аргументов в ситуации, когда имя одного из позиционных
аргументов начинается со знака минуса. Разберём описанные соглашения на примере
штатной утилиты `ls`, которая выводит содержимое папки. Мы не ставим
перед собой задачу досконально разобраться в списке параметров
утилиты `ls`, а всего лишь хотим продемонстрировать на наглядном
примере, как эти самые параметры могут быть использованы. Затем мы перейдём к
рассмотрению возможностей стандартной библиотеки языка Python в части,
касающейся разбора параметров командной строки.

Предположим, что мы
находимся в папке `/home/user/test` со следующей структурой:

.. code-block:: text

   /home/user/test
   ├── a
   │   ├── 1.txt
   │   └── 2.txt
   ├── b
   │   └── 3.txt
   └── -T
       └── 4.txt


Полный список параметров утилиты `ls` можно посмотреть в документации (для
этого наберите в терминале команду `man ls`). Согласно документации синтаксис
вызова утилиты следующий:

.. code-block:: text

    ls [OPTION]... [FILE]...

Т.е. сначала ожидаются опции, затем список файлов (или папок). Квадратные скобки
вокруг параметров обозначают, что эти параметры не являются обязательными.
Сперва вызовем команду без параметров:

.. code-block:: text

   ❯ ls
   a  b

Теперь изменим формат вывода, передав опцию `-l`:

.. code-block:: text

   ❯ ls -l
   итого 12
   drwxr-xr-x 2 user user 4096 янв 26 11:49 a
   drwxr-xr-x 2 user user 4096 янв 26 12:08 b
   drwxr-xr-x 2 user user 4096 янв 26 12:08 -T


Попробуем другую опцию, которая говорит утилите `ls` о том, что размеры файлов
следует выводить в удобном для чтения виде (т.е. в килобайтах, мегабайтах и
т.д.). Эта опция представлена как в коротком варианте `-h`, так и в длинном
`--human-readable`:

.. code-block:: text

   ❯ ls -l -h
   итого 8.0K
   drwxr-xr-x 2 user user 4.0K янв 26 11:49 a
   drwxr-xr-x 3 user user 4.0K янв 26 11:49 b
   drwxr-xr-x 2 user user 4.0K янв 26 12:08 -T
   ❯ ls -l --human-readable
   итого 8.0K
   drwxr-xr-x 2 user user 4.0K янв 26 11:49 a
   drwxr-xr-x 3 user user 4.0K янв 26 11:49 b
   drwxr-xr-x 2 user user 4.0K янв 26 12:08 -T
   ❯ ls -lh
   итого 8.0K
   drwxr-xr-x 2 user user 4.0K янв 26 11:49 a
   drwxr-xr-x 3 user user 4.0K янв 26 11:49 b
   drwxr-xr-x 2 user user 4.0K янв 26 12:08 -T

Обратите внимание на третий способ вызова: **короткие** опции, **не имеющие
параметра**, можно объединять, т.е. вместо `-l -h` можно просто написать `-lh`.

Теперь используем опцию, позволяющую скрыть некоторые файлы и папки. Она так же
представлена в двух вариантах:

.. code-block:: text

   ❯ ls --ignore=a
   b -T
   ❯ ls --ignore a
   b -T
   ❯ ls -I a
   b -T

Обратите внимание, как передаётся параметр для этой опции.

Перейдём к позиционным параметрам. Утилита `ls` ожидает, что в случае, когда
позиционные параметры присутствуют, они являются именами папок или файлов.
Выведем содержимое папки a:

.. code-block:: text

   ❯ ls a
   1.txt  2.txt

Попробуем объединить опции и позиционные параметры:

.. code-block:: text

   ❯ ls -h a
   1.txt  2.txt
   ❯ ls -hl a
   итого 8.0K
   -rw-r--r-- 1 user user 92 янв 26 11:49 1.txt
   -rw-r--r-- 1 user user 89 янв 26 11:49 2.txt
   ❯ ls -l --ignore 1.txt a
   итого 4
   -rw-r--r-- 1 user user 89 янв 26 11:49 2.txt

А теперь распечатаем содержимое директории `-T`. Если мы просто попытаемся
передать имя папки в качестве позиционного параметра, то он будет воспринят
командой `ls` как опция, поскольку начинается со знака минуса:

.. code-block:: text

   ❯ ls -T
   ls: ключ должен использоваться с аргументом — «T»
   По команде «ls --help» можно получить дополнительную информацию.

Поэтому для отделения опций от позиционных параметров нужно использовать
специальный аргумент `--`:

.. code-block:: text

   ❯ ls -- -T
   4.txt
   ❯ ls -l -- -T
   итого 4
   -rw-r--r-- 1 lx lx 45 янв 26 12:08 4.txt
   ❯ ls -l --human-readable -- -T
   итого 4.0K
   -rw-r--r-- 1 lx lx 45 янв 26 12:08 4.txt
   ❯ ls -lh -- -T
   итого 4.0K
   -rw-r--r-- 1 lx lx 45 янв 26 12:08 4.txt

Модуль argparse
---------------

Как было сказано ранее, очень многие программы (в большистве случаев консольные)
принимают параметры командной строки, поэтому в стандартную библиотеку языка
Python включён модуль `argparse`__, предназначенный для этих целей.

.. __: https://docs.python.org/3/library/argparse.html

Мы разберём только основные возможности этого модуля, об остальных вариантах
использования можно прочитать в официальной документации.

Рассмотрим в качестве примера реализацию программы, которая выводит среднее
арифметическое и среднеквадратическое отклонение чисел, переданных в качестве
позиционных параметров командной строки. Для вывода среднего значения
используется параметр `--mean`, для вывода среднеквадратического отклонения —
`--stdev`. Также программа принимает дополнительный параметр `--greater-than`,
позволяющий игнорировать числа, меньшие или равные заданному.

.. code-include:: code/lab16/stat.py
    :lexer: python
    :encoding: utf-8

Вывод такой программы при разных параметрах командной строки представлен ниже.

.. code-block:: text

   ❯ python3 ./stat.py
   usage: stat.py [-h] [-m] [-s] [-g VALUE] VALUES [VALUES ...]
   stat.py: error: the following arguments are required: VALUES


   ❯ python3 ./stat.py -h
   usage: stat.py [-h] [-m] [-s] [-g VALUE] VALUES [VALUES ...]

   Статистика для самых маленьких

   positional arguments:
     VALUES                входные данные

   optional arguments:
     -h, --help            show this help message and exit
     -m, --mean            вывести среднее значение
     -s, --stdev           вывести среднеквадратическое отклонение
     -g VALUE, --greater-than VALUE
                           игнорировать числа, меньшие или равне указанному


   ❯ python3 ./stat.py TEST
   usage: stat.py [-h] [-m] [-s] [-g VALUE] VALUES [VALUES ...]
   stat.py: error: argument VALUES: invalid float value: 'TEST'


   ❯ python3 ./stat.py 1 2 3
   Должен быть указан хотя бы один из параметров --mean и --stdev


   ❯ python3 ./stat.py --mean 1 2 3
   Среднее значение: 2.0


   ❯ python3 ./stat.py --mean --stdev 1 2 3
   Среднее значение: 2.0
   Среднеквадратическое отклонение: 0.8164965809277263


   ❯ python3 ./stat.py --mean --stdev -g 2 1 2 3
   Среднее значение: 3.0
   Среднеквадратическое отклонение: 0.0

Обратите внимание, что модуль при использовании парсера к допустимым параметрам
командной строки  автоматически добавляется ключ `-h`, `--help`, который выводит
подсказку по использованию программы. Многие программы следуют этому негласному
правилу и предоставляют справку по этому ключу, хотя, как мы видели раньше,
утилита `ls` использует его для других целей. Другим «зарезервированным» ключом
является `-v`, `--verbose`, который изменяет степень подробности вывода
вызываемой программы, но парсер из модуля `argparse` не добавляет его
автоматически.

Упражнение №2
+++++++++++++

Напишите консольный калькулятор. Он должен принимать два позиционных параметра —
числа, над которыми требуется выполнить действия. Также он должен принимать
опцию `-a`, `--action`, в качестве параметра для которой указывается знак
выполняемой арифметической операции (`+`, `-`, `*`, `/`). Также добавьте
возможность вывести само вычисляемое выражение со знаком равенства перед ответом
при помощи ключа `-v`, `--verbose`.

Работа с файловой системой
==========================

`Ранее`__ мы рассматривали, как организовать чтение даных из файла, а также
запись данных в файл. При этом вопросы, касающиеся непосредственной работы с
файловой системой (перебор файлов в директории, проверка существования файла и
т.д.) не рассматривались. Давайте рассмотрим минимальный набор функций
стандартной библиотеки языка Python, которая, конечно же, предоставляет такие
возможности.

.. __: http://judge.mipt.ru/mipt_cs_on_python3/labs/lab5.html#id5

Большинство таких функций определены в модуле `os`, который предоставляет
низкоуровневые инструменты взаимодействия с операционной системой. Перед тем,
как рассмотреть функции, следует освежить в памяти несколько терминов, которые
далее будут достаточно часто использоваться:

#. **Файловая система** — астракция, позволяющая построить
   однозначное обратимое отображение пользовательских структур данных
   (*файлов*, *каталогов*) на данные, которые могут храниться на физическом
   носителе (SSD, HDD и т.д.). `wiki`__

#. **Файл** — один из объектов, содержащихся на файловой системе. Представляет
   из себя именованную область данных на носителе информации. `wiki`__

#. **Каталог** (он же **директория**) — контейнер на файловой системе, который
   может содержать файлы. `wiki`__

#. **Текущая директория** — директория, указывающая в каком месте файловой
   системы следует искать файлы и каталоги, для которых указано только имя или
   относительный путь. `wiki`__

#. **Путь** — строка, однозначно идентифицирующая расположение объекта на
   файловой системе. Путь может быть **относительным** и **абсолютным** . Первый
   указывает на расположение объекта на файловой системе *относительно* текущей
   директории. Пример: `a/b.txt`, `../c/d.txt`, `x.txt`. Относительный путь
   указывает на положение файла вне зависимости от текущей директории. Пример:
   `/a/b/c/d.txt`. Стоит отметить, что при изменении текущей директории,
   относительный путь начинает идентифицировать другой объект или же вообще
   перестаёт идентифицировать какой-либо объект на файловой системе.

Многие современные файловые системы помимо каталогов и папок предоставляют
`жёсткие`__ и `символьные`__ ссылки, а также `специальные файлы`__ устройств.
Рассмотрение этих объектов выходит за рамки данного курса.

.. __: https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0
.. __: https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB
.. __: https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3_(%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0)
.. __: https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9_%D0%BA%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3
.. __: https://ru.wikipedia.org/wiki/%D0%96%D1%91%D1%81%D1%82%D0%BA%D0%B0%D1%8F_%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0
.. __: https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0
.. __: https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%84%D0%B0%D0%B9%D0%BB_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0

В таблице ниже перечислены базовые функции модуля `os`, необходимые для работы с файловой системой.


+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Название            | Описание                                                                                                                                                                             |
+=====================+======================================================================================================================================================================================+
| `os.getcwd`_        | Возвращает текущую директорию                                                                                                                                                        |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `os.chdir`_         | Изменяет текущую директорию                                                                                                                                                          |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `os.listdir`_       | Возвращает список файлов и папок в директории                                                                                                                                        |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `os.path.exists`_   | Проверяет, существует ли указанный путь (файл, директория и т.д.)                                                                                                                    |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `os.path.isfile`_   | Проверяет, является ли файлом объект по указанному пути                                                                                                                              |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `os.path.isdir`_    | Проверяет, является ли директорией объект по указанному пути                                                                                                                         |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `os.path.join`_     | Формирует строку, описывающую путь, «склеивая» переданные аргументы при помощи разделителя, используемого в операционной системе (например, `/` для GNU/Linux и `\ ` для MS Windows) |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `os.path.abspath`_  | Возвращает абсолютный путь                                                                                                                                                           |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `os.path.basename`_ | Возвращает имя объекта файловой системы (`c.txt` для `/a/b/c.txt`)                                                                                                                   |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `os.path.dirname`_  | Возвращает путь до родительского объекта файловой системы (`/a/b` для `/a/b/c.txt`)                                                                                                  |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

.. _`os.getcwd`: https://docs.python.org/3/library/os.html#os.getcwd
.. _`os.chdir`: https://docs.python.org/3/library/os.html#os.chdir
.. _`os.listdir`: https://docs.python.org/3/library/os.html#os.listdir
.. _`os.path.exists`: https://docs.python.org/3/library/os.path.html#os.path.exists
.. _`os.path.isdir`: https://docs.python.org/3/library/os.path.html#os.path.isdir
.. _`os.path.isfile`: https://docs.python.org/3/library/os.path.html#os.path.isfile
.. _`os.path.join`: https://docs.python.org/3/library/os.path.html#os.path.join
.. _`os.path.abspath`: https://docs.python.org/3/library/os.path.html#os.path.abspath
.. _`os.path.basename`: https://docs.python.org/3/library/os.path.html#os.path.basename
.. _`os.path.dirname`: https://docs.python.org/3/library/os.path.html#os.path.dirname

Упражнение №3
-------------

Напишите аналог системной утилиты `cat`. Ваша программа должна распечатывать последовательно все файлы, пути к которым
переданы параметрами командной строки. Пример работы программы:

.. code-block:: text

   ❯ python3 ./cat.py
   Укажите хотя бы один файл


   ❯ python3 ./cat.py 1.txt
   Это
   первый
   файл


   ❯ python3 ./cat.py 2.txt
   А
   это
   второй
   файл


   ❯ python3 ./cat.py 1.txt 2.txt
   Это
   первый
   файл
   А
   это
   второй
   файл


   ❯ python3 ./cat.py 2.txt 1.txt
   А
   это
   второй
   файл
   Это
   первый
   файл

Для разбора параметров **не** используйте `argparse`.


Упражнение №4
-------------

Напишите аналог утилиты `tree`, которая отображает древовидную структуру
каталогов и файлов. Пример работы программы:

.. code-block:: text

   ❯ python3 ./tree.py ~/file
   Указанный путь не существует или не является папкой


   ❯ python3 ./tree.py ~/test


   /home/user/test
      -T
         4.txt
      a
         1.txt
         2.txt
      b
         3.txt

Программа должна поддерживать следующие опции командной строки:

* `--folders-only` — не отображать файлы в дереве;
* `--include SOME_TEXT` — отображать только те элементы, в названии которых
  встречается текст SOME_TEXT
* `--exclude SOME_TEXT` — не отображать те элементы, в названии которых
  встречается текст SOME_TEXT

Для рабора параметров **используйте** модуль `argparse`.

Упражнение №5\*
---------------

Добавьте в программу `tree.py` параметр `--pretty`, изменяющий способ отрисовки
на дерево:

.. code-block:: text

   /home/user/test
   ├── -T
   │   └── 4.txt
   ├── a
   │   ├── 1.txt
   │   └── 2.txt
   └── b
       └── 3.txt

Символы для отрисовки дерева можно взять `тут`__.

.. __: https://ru.wikipedia.org/wiki/%D0%9F%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0

Упражнение №6\*
---------------

Добавьте в программу `tree.py` параметр `--max-depth=N`, ограничивающий глубину
отображаемого дерева.

Упражнение №7\*\*
-----------------

Напишите аналог утилиты `find`__, которая  ищет файлы. Список поддерживаемых опций:

* `--min-depth=N` — мнимальная глубина вложенности;
* `--max-depth=M` — максимальная глубина вложенности;
* `--name=X` — шаблон имени файла с учётом регистра;
* `--iname=Y` — шаблон имени файла без учёта регистра;

.. __: http://linux.die.net/man/1/find
