Объектно-ориентированное программирование
#########################################

:date: 2016-11-02
:lecture_link: https://youtu.be/V2ocqqh0Z_A
:lecture_link2: https://youtu.be/krwFyCHYz8I

.. default-role:: code
.. contents:: Содержание

Общая информация
================

При процедурном программировании программа разбивается на части в соответствии с алгоритмом: каждая функция является составной частью алгоритма. При объектно-ориентированном программировании программа строится как совокупность взаимодействующих объектов. Что же такое объект? С точки зрения объектно-ориентированного подхода, объект - это нечто, обладающее состоянием и поведением. По сути, состояние - это данные, соответствующие объекту, например рост, вес и громкость гавканья собаки. Поведением называется набор операций, которые можно производить с объектом. Например, в случае с собакой: покормить, погладить, погулять. Эти операции, которые можно выполнять над объектом обычно называют методами (по крайней мере в контексте языка Python).

Часто приходится работать с объектами одной природы. Например, если у нас несколько собак, то у них у всех одинаковые наборы данных (хотя значения могут различаться) и одинаковые методы. Для определения такой "общей природы" вводятся классы. Класс, по сути, есть шаблон объектов - базовое состояние и общее поведение для всех объектов этого класса.
Объекты одного класса называют экземплярами этого класса. Также, класс является типом данных для объектов.

В языке Python для определения класса используется оператор class. Рассмотрим следующий пример:

.. code-block:: python

        class Dog:
            def say_gaw(self): # имя self для первого аргумента метода это общепринятое но не обязательное правило
                print('Gaw-gaw')

        my_dog = Dog()
        another_dog = Dog()
        my_dog.say_gaw()      # вызовется функция Dog.say_gaw с параметром self = my_dog
        another_dog.say_gaw()

Здесь мы описали класс Dog, который задает один метод. При описании методов класса первый аргумент есть ссылка на экземепляр, для которого этот метод вызывается. Далее, мы создали пару собак и позвали для каждой метод say_gaw. Для создания объектов используется имя класса со скобками. Методы вызываются через точку после имени объекта. Заметте, что первый аргумент метода - self - при вызове указывать не нужно, т.к. им становится сам объект (тот для которого зовем метод, его имя перед точкой).

Для хранения данных в объектах испальзуются атрибуты. Это те самые "свойства" объекта - рост, вес и т.п. Атрибуты могут иметь любой тип данных. Так же как и с обычными переменными в Python, объявлять атрибуты неким специальным образом не нужно, они появляются автоматически, при первом приваивании, следующим образом:

.. code-block:: python

        class Dog:
            def say_gaw(self):
                if self.angry:
                    print('GAW-GAW')
                else:
                    print('Gaw-gaw')

            def ping(self):
                self.angry = True

            def feed(self, food_count):
                if food_count > 10:
                    self.angry = False

        my_dog = Dog()
        my_dog.feed(20)
        my_dog.say_gaw()      # напечатает Gaw-gaw
        my_dog.ping()
        my_dog.say_gaw()      # напечатает GAW-GAW

Часто для атрибутов хочется иметь некоторое начальное значение. В предыдущем примере есть проблема - если собака попытается гавкнуть до того как ее пнули или покормили, она навернется с ошибкой "AttributeError: 'Dog' object has no attribute 'angry'". Для решения этой проблемы используется метод со специальным именем - __init__, который вызывается автоматически при создании объекта:

.. code-block:: python

        class Dog:
            def __init__(self):
                self.angry = False

            def say_gaw(self):
                if self.angry:
                    print('GAW-GAW')
                else:
                    print('Gaw-gaw')

        my_dog = Dog()
        my_dog.say_gaw()      # ошибки нет, напечатает Gaw-gaw

Метод `__init__` называется конструктором. Собственно, конструктор зовется при выполнении конструкции вида `ИмяКласса()`, в нашем случае - `Dog()`. Аргументом `self` для конструктора становится вновь созданный объект. Конструктор, также как и обычные методы, может иметь дополнительные аргументы кроме `self`. Эти аргументы передаются при создании объекта, следующим образом:

.. code-block:: python

        class Dog:
            def __init__(self, angry, count):
                self.angry = angry
                self.count = count

            def say_gaw(self):
                if self.angry:
                    print('GAW-' * self.count)
                else:
                    print('gaw-' * self.count)

        my_dog = Dog(True, 3)
        my_dog.say_gaw()      # ошибки нет, напечатает Gaw-gaw

Класс в Python также является объектом. Объект создается с помощью ключевого слова class, как в примерах выше. Таким образом, в предыдущем примере вызов `my_dog.say_gaw()` эквивалентен вызову `Dog.say_gaw(my_dog)`. Разобраться, какой объект какому классу принадлежит помогут встроенные функции `type` и `isinstance`:

.. code-block:: python
        
        >>> class A:
        ...     pass
        ... 
        >>> a = A()
        >>> type(a)
        <class '__main__.A'>
        >>> type(A)
        <class 'type'>
        >>> type(type)
        <class 'type'>
        >>> type(1)
        <class 'int'>
        >>> type(int)
        <class 'type'>
        >>> 
        >>> isinstance(1, int)
        True
        >>> isinstance(1, A)
        False
        >>> isinstance(a, A)
        True
        >>> isinstance(type, type)
        True
        >>> isinstance(A, type)
        True

Примечание: здесь был объявлен, в тестовых целях, пустой класс A - в нем нет никаких методов.

Нужно заметить также, что методы, которые класс определяет, не будут методами для него (как для объекта), а будут просто атрибутами типа `function`. Действительно, при вызове `Dog.say_gaw(my_dog)` никакой дополнительный `self` уже не передается, функция запускается в том виде, в котором мы ее написали. Это также можно показать следующим образом:

.. code-block:: python
        
        >>> class A:
        ...     def f(self):
        ...         print('hello')
        ... 
        >>> 
        >>> type(A.f)
        <class 'function'>
        >>> a = A()
        >>> type(a.f)
        <class 'method'>

То есть, A.f - это функция, а a.f - метод. Метод здесь это объект, который содержит в себе ссылку на объект, за которым этот метод закреплен (в нашем случае это объект `a`) и ссылку на функцию, которую надо вызывать. Соответственно при вызове метод завет эту функцию, передавя ссылку на свой объект как первый аргумент и прокидывая остальные аргументы.

.. code-block:: python

        >>> m = a.f
        >>> m is A.f
        False
        >>> m.__func__ is A.f
        True
        >>> m.__self__ is a
        True
        >>> m.__func__(m.__self__)
        hello
        >>> m()
        hello
        >>> a.f()
        hello
        >>> A.f(a)
        hello

Упражнения - игра "Пушка"
=========================

Упражнение №1
+++++++++++++
Команда студентов начала разрабатывать игру "Пушка". Для тестирования использовался обфусцированный исходный файл, который позволяет увидеть процесс, но скрывает исходный код: `obfuscated`_

.. _obfuscated: {filename}/code/lab10/gun_obfuscated.py

В результате празднования окончания сессии компьютер, на котором лежали работающие исходники, был испорчен. На флешке была найдена только промежуточная версия. 
Помогите восстановить работоспособность программы используя имеющийся исходный код: `gunsource`_

.. _gunsource: {filename}/code/lab10/gun.py

Подсказка: для начала, исправте код так, чтобы он запускался, и поправте все 'FIXME'.

Упражнение №2
+++++++++++++
Улучшите программу из №1 добавив 2 цели.

Упражнение №3
+++++++++++++
Улучшите программу из №2 сделав цели движущимися.

Стандартные методы
==================

Кроме __init__ есть и другие стандартные методы, которые можно определить в описании класса.

Метод __repr__ должен возвращать текстовую строку, содержащую код (на языке Python), создающую объект, равный данному. Естественно, метод __repr__ должен содержать вызов конструктора, которому передаются в качестве параметров все строки исходного объекта, то есть он должен возвращать строку вида "Person('Иванов', 5)"

Пример метода __repr__ (для экономии места опустим описание конструктора __init__):

.. code-block:: python

        class Dog:
            def __repr__(self):
                return "Dog('" + self.angry + "', " + self.count + ")"

Таким образом, метод __repr__ возвращает строку с описанием объекта, которое может быть воспринято итерпретатором языка Питон.

Метод __str__ возвращает строку, являющуюся описанием объекта в том виде, в котором его удобно будет воспринимать человеку. Здесь не нужно выводить имя конструктора, можно, например, просто вернуть строку с содержимым всех полей:

.. code-block:: python

        class Dog
            def __str__(self):
                return self.name + ' ' + str(self.score)

Метод __str__ будет вызываться, когда вызывается функция str от данного объекта, например, str(Vasya). То есть создавая метод __str__ вы даете указание Питону, как преобразовывать данный объект к типу str.

Поскольку функция print использует именно функцию str для вывода объекта на экран, то определение метода __str__ позволит выводить объекты на экран удобным способом: при помощи print.

Переопределение стандартных операций
====================================

Рассмотрим класс Vector, используемый для представления радиус-векторов на координатной плоскости, и определим в нем поля-координаты: x и y. Также очень хотелось бы определить для векторов операцию +, чтобы их можно было складывать столь же удобно, как и числа или строки. Например, чтобы можно было записать так:

.. code-block:: python

        A = Vector(1, 2)
        B = Vector(3, 4)
        C = A + B

Для этого необходимо перегрузить операцию +: определить функцию, которая будет использоваться, если операция + будет вызвана для объекта класса Vector. Для этого нужно определить метод __add__ класса Vector, у которого два параметра: неявная ссылка self на экземпляр класса, для которого она будет вызвана (это левый операнд операции +) и явная ссылка other на правый операнд:

.. code-block:: python

        class Vector:
            def __init__(self, x = 0, y = 0):
                self.x = x
                self.y = y
            def __add__(self, other):
                return Vector(self.x + other.x, self.y + other.y)

Теперь при вызове оператора A + B Питон вызовет метод A.__add__(B), то есть вызовет указанный метод, где self = A, other = B.

Аналогично можно определить и оставшиеся операции. Полезной для переопределения является операция <. Она должна возвращать логическое значение True, если левый операнд меньше правого или False в противном случае (также в том случае, если объекты равны). Для переопределения этого операнда нужно определить метод __lt__ (less than):

.. code-block:: python

        class Vector:
            def __lt__(self, other):
                return self.x < other.x or self.x == other.x and self.y < other.y

В этом примере оператор вернет True, если у левого операнда поле x меньше, чем у правого операнда, а также если поля x у них равны, а поле y меньше у левого операнда.

После определения оператора <, появляется возможность упорядочивать объекты, используя этот оператор. Теперь можно сортировать списки объектов при помощи метода sort() или функции sorted, при этом будет использоваться именно определенный оператор сравнения <.

Список возможных перегружаемых операторов

Следующая таблица взята из книги Саммерфильда (стр. 283 и далее).

+---------------------------------+------------------+
| Метод                           | Использование    |
+=================================+==================+
| Операторы сравнения                                |
+---------------------------------+------------------+
| __lt__(self, other)             | x < y            |
+---------------------------------+------------------+
| __le__(self, other)             | x <= y           |
+---------------------------------+------------------+
| __eq__(self, other)             | x == y           |
+---------------------------------+------------------+
| __ne__(self, other)             | x != y           |
+---------------------------------+------------------+
| __gt__(self, other)             | x > y            |
+---------------------------------+------------------+
| __ge__(self, other)             | x >= y           |
+---------------------------------+------------------+
| Арифметические операторы                           |
+----------------------------------------------------+
| Сложение                                           |
+---------------------------------+------------------+
| __add__(self, other)            | x + y            |
+---------------------------------+------------------+
| __radd__(self, other)           | y + x            |
+---------------------------------+------------------+
| __iadd__(self, other)           | x += y           |
+---------------------------------+------------------+
| Вычитание                                          |
+---------------------------------+------------------+
| __sub__(self, other)            | x - y            |
+---------------------------------+------------------+
| __rsub__(self, other)           | y - x            |
+---------------------------------+------------------+
| __isub__(self, other)           | x -= y           |
+---------------------------------+------------------+
| Умножение                                          |
+---------------------------------+------------------+
| __mul__(self, other)            | ``x * y``        |
+---------------------------------+------------------+
| __rmul__(self, other)           | ``y * x``        |
+---------------------------------+------------------+
| __imul__(self, other)           | ``x *= y``       |
+---------------------------------+------------------+
| Деление                                            |
+---------------------------------+------------------+
| __truediv__(self, other)        | x / y            |
+---------------------------------+------------------+
| __rtruediv__(self, other)       | y / x            |
+---------------------------------+------------------+
| __itruediv__(self, other)       | x /= y           |
+---------------------------------+------------------+
| Целочисленное деление                              |
+---------------------------------+------------------+
| __floordiv__(self, other)       | x // y           |
+---------------------------------+------------------+
| __rfloordiv__(self, other)      | y // x           |
+---------------------------------+------------------+
| __ifloordiv__(self, other)      | x //= y          |
+---------------------------------+------------------+
| __divmod__(self, other)         | divmod(x, y)     |
+---------------------------------+------------------+
| Остаток                                            |
+---------------------------------+------------------+
| __mod__(self, other)            | x % y            |
+---------------------------------+------------------+
| __rmod__(self, other)           | y % x            |
+---------------------------------+------------------+
| __imod__(self, other)           | x %= y           |
+---------------------------------+------------------+
| Возведение в степень                               |
+---------------------------------+------------------+
| __pow__(self, other)            | ``x ** y``       |
+---------------------------------+------------------+
| __rpow__(self, other)           | ``y ** x``       |
+---------------------------------+------------------+
| __ipow__(self, other)           | ``x **= y``      |
+---------------------------------+------------------+
| Отрицание, модуль                                  |
+---------------------------------+------------------+
| __pos__(self)                   | +x               |
+---------------------------------+------------------+
| __neg__(self)                   | -x               |
+---------------------------------+------------------+
| __abs__(self)                   | abs(x)           |
+---------------------------------+------------------+
| Преобразование к стандартным типам                 |
+---------------------------------+------------------+
| __int__(self)                   | int(x)           |
+---------------------------------+------------------+
| __float__(self)                 | float(x)         |
+---------------------------------+------------------+
| __str__(self)                   | str(x)           |
+---------------------------------+------------------+
| __round__(self, digits = 0)     | round(x, digits) |
+---------------------------------+------------------+

Упражнения - класс Vector
=========================

Упражнение №1
+++++++++++++
Создайте класс Vector с полями x и y, определите для него конструктор, метод __str__, необходимые арифметические операции. Реализуйте конструктор, который принимает строку в формате "x,y".

Упражнение №2
+++++++++++++
Программа получает на вход число N, далее координаты N точек. Доопределите в классе Vector недостающие операторы, найдите и выведите координаты точки, наиболее удаленной от начала координат.

Упражнение №3
+++++++++++++
Используя класс Vector выведите координаты центра масс данного множества точек.

Упражнение №4
+++++++++++++
Среди данных точек найдите три точки, образующие треугольник с наибольшим периметром. Выведите данный периметр.

Упражнение №5
+++++++++++++
Среди данных точек найдите три точки, образующие треугольник с наибольшей площадью. Выведите данную площадь.
